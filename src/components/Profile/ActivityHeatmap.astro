---
interface Props {
    year: number;
    events: Array<{
        type: string;
        post: any;
        date: Date;
        title: string;
        count?: number;
    }>;
}

const { year, events } = Astro.props;

// Count activity per day from events (using displayDate which is publishedDate or git date)
const activityMap: Record<string, number> = {};
events.forEach((event) => {
    const dateStr = event.date.toISOString().split("T")[0];
    activityMap[dateStr] = (activityMap[dateStr] || 0) + 1;
});

interface DayData {
    date: string;
    count: number;
}

// Generate all days for the specified year (January 1 to December 31)
const days: (DayData | null)[] = [];
const startDate = new Date(year, 0, 1); // January 1st
const endDate = new Date(year, 11, 31); // December 31st

// Add padding for the first week so Sunday starts at top
const startPadding = startDate.getDay(); // 0 is Sunday, 1 is Monday...
for (let i = 0; i < startPadding; i++) {
    days.push(null);
}

for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    const dateStr = d.toISOString().split("T")[0];
    days.push({
        date: dateStr,
        count: activityMap[dateStr] || 0,
    });
}

// Configuration for compact vertical layout (Sunday top, Saturday bottom)
const SQUARE_SIZE = 10;
const SQUARE_GAP = 3;

function getColor(count: number) {
    if (count === 0) return "fill-stone-200 dark:fill-slate-800";
    if (count === 1) return "fill-blue-300 dark:fill-blue-900";
    if (count === 2) return "fill-blue-500 dark:fill-blue-700";
    if (count >= 3) return "fill-blue-600 dark:fill-blue-600";
    return "fill-stone-200 dark:fill-slate-800";
}

// Calculate SVG dimensions - columns are weeks, rows are days (Sun-Sat)
const numWeeks = Math.ceil(days.length / 7);
const svgWidth = numWeeks * (SQUARE_SIZE + SQUARE_GAP) - SQUARE_GAP + 20;
const svgHeight = 7 * (SQUARE_SIZE + SQUARE_GAP) - SQUARE_GAP + 10;
---

<div
    id="activity-heatmap"
>
    <div
        id="heatmap-tooltip"
        class="fixed hidden z-50 px-3 py-1.5 text-xs font-semibold text-white bg-stone-800 shadow-lg pointer-events-none whitespace-nowrap rounded"
    >
    </div>

    <!-- Legend -->
    <div class="flex justify-end items-center gap-2 mb-3">
        <div class="flex items-center gap-1">
            <div class="w-2.5 h-2.5 rounded-sm bg-stone-200 dark:bg-slate-800"></div>
            <div class="w-2.5 h-2.5 rounded-sm bg-blue-300 dark:bg-blue-900"></div>
            <div class="w-2.5 h-2.5 rounded-sm bg-blue-500 dark:bg-blue-700"></div>
            <div class="w-2.5 h-2.5 rounded-sm bg-primary dark:bg-primary"></div>
        </div>
    </div>

    <div class="overflow-x-auto no-scrollbar">
        <svg
            viewBox={`0 0 ${svgWidth} ${svgHeight}`}
            preserveAspectRatio="xMinYMin meet"
            class="w-full activity-heatmap-svg"
        >
            {
                Array.from({ length: Math.ceil(days.length / 7) }).map(
                    (_, weekIndex) => (
                        <g transform={`translate(${weekIndex * (SQUARE_SIZE + SQUARE_GAP) + 10}, 5)`}>
                            {Array.from({ length: 7 }).map((_, dayIndex) => {
                                const dayData = days[weekIndex * 7 + dayIndex];
                                if (!dayData) return null;
                                return (
                                    <rect
                                        x="0"
                                        y={dayIndex * (SQUARE_SIZE + SQUARE_GAP)}
                                        width={SQUARE_SIZE}
                                        height={SQUARE_SIZE}
                                        rx="1"
                                        class={`${getColor(dayData.count)} activity-day hover:stroke-primary hover:stroke-2 ${dayData.count > 0 ? "cursor-pointer" : ""}`}
                                        data-date={dayData.date}
                                        data-count={dayData.count}
                                        onclick={
                                            dayData.count > 0
                                                ? `filterByDate('${dayData.date}')`
                                                : undefined
                                        }
                                    />
                                );
                            })}
                        </g>
                    ),
                )
            }
        </svg>
    </div>

    <script is:inline define:vars={{ events, year }}>
        // Store the currently selected date and year
        let selectedDate = null;

        // Initialize currentYear to the year provided by the server.
        // This MUST match what was rendered in the HTML initially.
        let currentYear = year;
        const allEvents = events;

        // Configuration for compact vertical layout (must match Astro frontmatter)
        const SQUARE_SIZE = 10;
        const SQUARE_GAP = 3;

        // Function to get Tailwind classes for colors
        function getColor(count) {
          if (count === 0) return "fill-stone-200 dark:fill-slate-800";
          if (count === 1) return "fill-blue-300 dark:fill-blue-900";
          if (count === 2) return "fill-blue-500 dark:fill-blue-700";
          if (count >= 3) return "fill-blue-600 dark:fill-blue-600";
          return "fill-stone-200 dark:fill-slate-800";
        }

        // Function to update heatmap for a specific year
        window.updateHeatmapYear = function (newYear) {
            if (currentYear === newYear) return;
            currentYear = newYear;

            // Clear selected date when changing years
            selectedDate = null;
            const heatmap = document.getElementById("activity-heatmap");
            heatmap?.classList.remove("is-filtering");

            const event = new CustomEvent("dateFilterChange", {
                detail: { date: null },
            });
            window.dispatchEvent(event);

            // Generate new data for year
            const activityMap = {};
            allEvents.forEach((event) => {
                // event.date is serialized as string, convert back to Date
                const eventDate = new Date(event.date);
                const eventYear = eventDate.getFullYear();
                if (eventYear === newYear) {
                    const dateStr = eventDate.toISOString().split("T")[0];
                    activityMap[dateStr] = (activityMap[dateStr] || 0) + 1;
                }
            });

            // Generate all days for year with padding for Sunday start
            const days = [];
            const startDate = new Date(newYear, 0, 1);
            const endDate = new Date(newYear, 11, 31);

            // Add padding for the first week so Sunday starts at top
            const startPadding = startDate.getDay();
            for (let i = 0; i < startPadding; i++) {
                days.push(null);
            }

            for (
                let d = new Date(startDate);
                d <= endDate;
                d.setDate(d.getDate() + 1)
            ) {
                const dateStr = d.toISOString().split("T")[0];
                days.push({
                    date: dateStr,
                    count: activityMap[dateStr] || 0,
                });
            }

            // Calculate SVG dimensions - columns are weeks, rows are days (Sun-Sat)
            const numWeeks = Math.ceil(days.length / 7);
            const svgWidth = numWeeks * (SQUARE_SIZE + SQUARE_GAP) - SQUARE_GAP + 20;
            const svgHeight = 7 * (SQUARE_SIZE + SQUARE_GAP) - SQUARE_GAP + 10;

            // Update SVG - rebuild everything for new year
            const svg = document.querySelector(".activity-heatmap-svg");
            if (!svg) return;

            // Update viewBox
            svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);

            // Clear SVG content completely
            while (svg.firstChild) {
                svg.removeChild(svg.firstChild);
            }

            // Rebuild day rectangles in vertical column layout (Sun top, Sat bottom)
            for (let weekIndex = 0; weekIndex < numWeeks; weekIndex++) {
                const g = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "g",
                );
                const x = weekIndex * (SQUARE_SIZE + SQUARE_GAP) + 10;
                g.setAttribute("transform", `translate(${x}, 5)`);

                for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
                    const dataIndex = weekIndex * 7 + dayIndex;
                    if (dataIndex >= days.length) break;

                    const dayData = days[dataIndex];
                    if (!dayData) continue;

                    const rect = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "rect",
                    );
                    rect.setAttribute("x", "0");
                    rect.setAttribute("y", String(dayIndex * (SQUARE_SIZE + SQUARE_GAP)));
                    rect.setAttribute("width", String(SQUARE_SIZE));
                    rect.setAttribute("height", String(SQUARE_SIZE));
                    rect.setAttribute("rx", "1");
                    rect.setAttribute("data-date", dayData.date);
                    rect.setAttribute("data-count", String(dayData.count));

                    rect.setAttribute(
                        "class",
                        `activity-day ${getColor(dayData.count)} ${dayData.count > 0 ? "cursor-pointer" : ""}`,
                    );

                    if (dayData.count > 0) {
                        rect.onclick = function () {
                            window.filterByDate(dayData.date);
                        };
                    }

                    g.appendChild(rect);
                }

                svg.appendChild(g);
            }
        };

        // Function to filter posts by date
        window.filterByDate = function(dateString) {
            const heatmap = document.getElementById("activity-heatmap");

            // If clicking the same date, clear the filter
            if (selectedDate === dateString) {
                selectedDate = null;
                heatmap?.classList.remove("is-filtering");
                // Clear any existing date filters
                const event = new CustomEvent("dateFilterChange", {
                    detail: { date: null },
                });
                window.dispatchEvent(event);
                // Reset visual feedback
                document
                    .querySelectorAll(".activity-day.selected")
                    .forEach((el) => {
                        el.classList.remove("selected");
                    });
                return;
            }

            selectedDate = dateString;
            heatmap?.classList.add("is-filtering");

            // Dispatch custom event to notify the main filtering system
            const event = new CustomEvent("dateFilterChange", {
                detail: { date: dateString },
            });
            window.dispatchEvent(event);

            // Add visual feedback to selected day
            document
                .querySelectorAll(".activity-day.selected")
                .forEach((el) => {
                    el.classList.remove("selected");
                });

            // Find and highlight the clicked day
            const clickedDay = document.querySelector(
                `[data-date="${dateString}"]`,
            );
            if (clickedDay) {
                clickedDay.classList.add("selected");
            }
        }

        // Tooltip logic
        const tooltip = document.getElementById("heatmap-tooltip");
        const svgElement = document.querySelector(".activity-heatmap-svg");

        function formatDate(dateStr) {
            const date = new Date(dateStr + "T00:00:00");
            return date.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
                year: "numeric",
            });
        }

        if (svgElement && tooltip) {
            svgElement.addEventListener("mouseover", (e) => {
                const target = e.target;
                if (target.tagName === "rect" && target.classList.contains("activity-day")) {
                    const count = parseInt(target.getAttribute("data-count") || "0");
                    const date = target.getAttribute("data-date");
                    const formattedDate = formatDate(date);

                    let text = "";
                    if (count === 0) text = `No Activity // ${formattedDate}`;
                    else if (count === 1) text = `1 Update // ${formattedDate}`;
                    else text = `${String(count)} Updates // ${formattedDate}`;

                    tooltip.textContent = text;

                    // Position relative to the rect
                    const rect = target.getBoundingClientRect();
                    tooltip.style.left = `${rect.left + rect.width / 2}px`;
                    tooltip.style.top = `${rect.top - 8}px`;
                    tooltip.style.transform = "translate(-50%, -100%)";

                    tooltip.classList.remove("hidden");
                }
            });

            svgElement.addEventListener("mouseout", (e) => {
                const target = e.target;
                if (target.tagName === "rect" && target.classList.contains("activity-day")) {
                    tooltip.classList.add("hidden");
                }
            });
        }

        // Add selected class styling
        const style = document.createElement("style");
        style.textContent = `
  			.activity-day.selected {
  				stroke: #2563eb !important;
  				stroke-width: 2px !important;
  			}
            #activity-heatmap.is-filtering .activity-day:not(.selected) {
                opacity: 0.1;
            }
            #activity-heatmap.is-filtering .activity-day.selected {
                opacity: 1;
            }
  		`;
        document.head.appendChild(style);
        // Initialize from attribute or default
        const initialYear = parseInt(document.documentElement.getAttribute('data-selected-year')) || year;
        if (initialYear !== year) {
            window.updateHeatmapYear(initialYear);
        }
    </script>
</div>
