---
interface Props {
    year: number;
    events: Array<{
        type: string;
        post: any;
        date: Date;
        title: string;
        count?: number;
    }>;
}

const { year, events } = Astro.props;

// Count activity per day from events (using displayDate which is publishedDate or git date)
const activityMap: Record<string, number> = {};
events.forEach((event) => {
    const dateStr = event.date.toISOString().split("T")[0];
    activityMap[dateStr] = (activityMap[dateStr] || 0) + 1;
});

interface DayData {
    date: string;
    count: number;
}

interface MonthLabel {
    name: string;
    weekIndex: number;
}

// Generate all days for the specified year (January 1 to December 31)
const days: (DayData | null)[] = [];
const startDate = new Date(year, 0, 1); // January 1st
const endDate = new Date(year, 11, 31); // December 31st

// Add padding for the first week so the grid always starts on Sunday
const startPadding = startDate.getDay(); // 0 is Sunday, 1 is Monday...
for (let i = 0; i < startPadding; i++) {
    days.push(null);
}

for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    const dateStr = d.toISOString().split("T")[0];
    days.push({
        date: dateStr,
        count: activityMap[dateStr] || 0,
    });
}

// Generate month labels for the year
const monthLabels: MonthLabel[] = [];
let lastMonth = "";
for (let i = 0; i < days.length; i++) {
    const dayData = days[i];
    if (!dayData) continue;

    const d = new Date(dayData.date);
    const monthKey = d.toLocaleDateString("en-US", { month: "short" });
    if (monthKey !== lastMonth) {
        const weekIndex = Math.floor(i / 7);
        // Only include months that are actually in this year and not too close to end
        if (d.getFullYear() === year && weekIndex < 52) {
            monthLabels.push({
                name: monthKey,
                weekIndex: weekIndex,
            });
        }
        lastMonth = monthKey;
    }
}

function getColor(count: number) {
    if (count === 0) return "fill-slate-100 dark:fill-slate-800";
    if (count === 1) return "fill-blue-200 dark:fill-blue-900/40";
    if (count === 2) return "fill-blue-400 dark:fill-blue-700/60";
    if (count >= 3) return "fill-[#0055FF] dark:fill-[#0055FF]";
    return "fill-slate-100 dark:fill-slate-800";
}

function getFillColor(count: number, isDarkMode: boolean) {
    // Light mode colors (based on getColor)
    if (!isDarkMode) {
        if (count === 0) return "#f1f5f9"; // tooling-gray
        if (count === 1) return "#bfdbfe"; // blue-200
        if (count === 2) return "#60a5fa"; // blue-400
        if (count >= 3) return "#0055FF"; // blueprint-blue
        return "#f1f5f9";
    }
    // Dark mode colors
    if (count === 0) return "#1e293b";
    if (count === 1) return "#1e3a8a66"; // blue-900/40
    if (count === 2) return "#1d4ed899"; // blue-700/60
    if (count >= 3) return "#0055FF"; // blueprint-blue
    return "#1e293b";
}

// Keep the original getColor function for static rendering
---

<div
    id="activity-heatmap"
    class="relative bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 p-8 shadow-[4px_4px_0_0_#f1f5f9] dark:shadow-none"
>
    <div
        id="heatmap-tooltip"
        class="fixed hidden z-50 px-3 py-1.5 metadata text-xs font-bold text-white bg-terminal-dark shadow-lg pointer-events-none whitespace-nowrap"
    >
    </div>
    <div class="flex items-center justify-between mb-8">
        <h3 class="text-xs font-sans font-bold text-slate-500 dark:text-slate-400 tracking-widest uppercase">
            Activity Heatmap
        </h3>
        <span
            id="heatmap-year-display"
            class="metadata text-xs font-bold text-blue-600"
        >
            {year}
        </span>
    </div>
    <div class="overflow-x-auto pb-4 custom-scrollbar">
        <svg
            viewBox="0 0 780 125"
            preserveAspectRatio="xMinYMin meet"
            class="w-full activity-heatmap-svg min-w-[700px]"
        >
            <!-- Day labels -->
            <text x="0" y="33" class="metadata fill-slate-400 dark:fill-slate-500 text-xs">SUN</text>
            <text x="0" y="59" class="metadata fill-slate-400 dark:fill-slate-500 text-xs">TUE</text>
            <text x="0" y="85" class="metadata fill-slate-400 dark:fill-slate-500 text-xs">THU</text>
            <text x="0" y="111" class="metadata fill-slate-400 dark:fill-slate-500 text-xs">SAT</text>

            {
                monthLabels.map((label) => (
                    <text
                        x={label.weekIndex * 14 + 30}
                        y="12"
                        text-anchor="start"
                        class="metadata fill-slate-400 dark:fill-slate-500 text-xs tracking-widest"
                    >
                        {label.name.toUpperCase()}
                    </text>
                ))
            }
            {
                Array.from({ length: Math.ceil(days.length / 7) }).map(
                    (_, weekIndex) => (
                        <g transform={`translate(${weekIndex * 14 + 30}, 24)`}>
                            {Array.from({ length: 7 }).map((_, dayIndex) => {
                                const dayData = days[weekIndex * 7 + dayIndex];
                                if (!dayData) return null;
                                return (
                                    <rect
                                        x="0"
                                        y={dayIndex * 13}
                                        width="11"
                                        height="11"
                                        rx="0"
                                        class={`${getColor(dayData.count)} activity-day transition-all duration-300 hover:stroke-blueprint-blue hover:stroke-2 ${dayData.count > 0 ? "cursor-pointer" : ""}`}
                                        data-date={dayData.date}
                                        data-count={dayData.count}
                                        onclick={
                                            dayData.count > 0
                                                ? `filterByDate('${dayData.date}')`
                                                : undefined
                                        }
                                    />
                                );
                            })}
                        </g>
                    ),
                )
            }
        </svg>
    </div>
    <div
        class="mt-8 flex items-center justify-end gap-3 metadata text-xs text-slate-500 dark:text-slate-400 tracking-[0.2em]"
    >
        <span>Min Level</span>
        <div class="w-3 h-3 bg-slate-100 dark:bg-slate-800"></div>
        <div class="w-3 h-3 bg-blue-200 dark:bg-blue-900/40">
        </div>
        <div class="w-3 h-3 bg-blue-400 dark:bg-blue-700/60">
        </div>
        <div class="w-3 h-3 bg-[#0055FF]">
        </div>
        <span>Max Level</span>
    </div>

    <script define:vars={{ events, year }}>
        // Store the currently selected date and year
        let selectedDate = null;

        // Initialize currentYear to the year provided by the server.
        // This MUST match what was rendered in the HTML initially.
        let currentYear = year;

        // Function to get Tailwind classes for colors
        function getColor(count) {
            if (count === 0) return "fill-slate-100 dark:fill-slate-800";
            if (count === 1) return "fill-blue-200 dark:fill-blue-900/40";
            if (count === 2) return "fill-blue-400 dark:fill-blue-700/60";
            if (count >= 3) return "fill-[#0055FF]";
            return "fill-slate-100 dark:fill-slate-800";
        }

        // Function to update heatmap for a specific year
        window.updateHeatmapYear = function (newYear) {
            if (currentYear === newYear) return;
            currentYear = newYear;

            // Update year display
            const yearDisplay = document.getElementById("heatmap-year-display");
            if (yearDisplay) {
                yearDisplay.textContent = String(newYear);
            }

            // Clear selected date when changing years
            selectedDate = null;
            const heatmap = document.getElementById("activity-heatmap");
            heatmap?.classList.remove("is-filtering");

            const event = new CustomEvent("dateFilterChange", {
                detail: { date: null },
            });
            window.dispatchEvent(event);

            // Generate new data for year
            const activityMap = {};
            events.forEach((event) => {
                // event.date is serialized as string, convert back to Date
                const eventDate = new Date(event.date);
                const eventYear = eventDate.getFullYear();
                if (eventYear === newYear) {
                    const dateStr = eventDate.toISOString().split("T")[0];
                    activityMap[dateStr] = (activityMap[dateStr] || 0) + 1;
                }
            });

            // Generate all days for year - match format from commits
            const days = [];
            const startDate = new Date(newYear, 0, 1);
            const endDate = new Date(newYear, 11, 31);

            // Add padding for the first week so the grid always starts on Sunday
            const startPadding = startDate.getDay();
            for (let i = 0; i < startPadding; i++) {
                days.push(null);
            }

            for (
                let d = new Date(startDate);
                d <= endDate;
                d.setDate(d.getDate() + 1)
            ) {
                const dateStr = d.toISOString().split("T")[0];
                days.push({
                    date: dateStr,
                    count: activityMap[dateStr] || 0,
                });
            }

            // Update SVG - rebuild everything for new year
            const svg = document.querySelector(".activity-heatmap-svg");
            if (!svg) return;

            // Clear SVG content completely
            while (svg.firstChild) {
                svg.removeChild(svg.firstChild);
            }

            // Add day labels to SVG
            const dayLabels = [
                { name: "Sun", y: 33 },
                { name: "Tue", y: 59 },
                { name: "Thu", y: 85 },
                { name: "Sat", y: 111 }
            ];

            dayLabels.forEach(label => {
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", "0");
                text.setAttribute("y", String(label.y));
                text.setAttribute("class", "metadata fill-slate-400 dark:fill-slate-500");
                text.setAttribute("font-size", "8px");
                text.textContent = label.name.toUpperCase();
                svg.appendChild(text);
            });

            // Rebuild month labels
            const monthLabels = [];
            let lastMonth = "";
            const isDarkMode =
                document.documentElement.classList.contains("dark");

            for (let i = 0; i < days.length; i++) {
                const dayData = days[i];
                if (!dayData) continue;

                const d = new Date(dayData.date);
                const monthKey = d.toLocaleDateString("en-US", {
                    month: "short",
                });
                if (monthKey !== lastMonth) {
                    const weekIndex = Math.floor(i / 7);
                    if (d.getFullYear() === newYear && weekIndex < 52) {
                        monthLabels.push({
                            name: monthKey,
                            weekIndex: weekIndex,
                        });
                    }
                    lastMonth = monthKey;
                }
            }

            // Add month labels to SVG
            monthLabels.forEach((label) => {
                const text = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "text",
                );
                text.setAttribute("x", String(label.weekIndex * 14 + 30));
                text.setAttribute("y", "12");
                text.setAttribute("text-anchor", "start");
                text.setAttribute("class", "metadata fill-slate-400 dark:fill-slate-500");
                text.setAttribute("font-size", "9px");
                text.textContent = label.name.toUpperCase();
                svg.appendChild(text);
            });

            // Rebuild day rectangles
            const numWeeks = Math.ceil(days.length / 7);

            for (let weekIndex = 0; weekIndex < numWeeks; weekIndex++) {
                const g = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "g",
                );
                g.setAttribute("transform", `translate(${weekIndex * 14 + 30}, 24)`);

                for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
                    const dataIndex = weekIndex * 7 + dayIndex;
                    if (dataIndex >= days.length) break;

                    const dayData = days[dataIndex];
                    if (!dayData) continue;

                    const rect = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "rect",
                    );
                    rect.setAttribute("x", "0");
                    rect.setAttribute("y", String(dayIndex * 13));
                    rect.setAttribute("width", "12");
                    rect.setAttribute("height", "12");
                    rect.setAttribute("rx", "0");
                    rect.setAttribute("data-date", dayData.date);
                    rect.setAttribute("data-count", String(dayData.count));

                    rect.setAttribute(
                        "class",
                        `activity-day ${getColor(dayData.count)} transition-all duration-300 ${dayData.count > 0 ? "cursor-pointer" : ""}`,
                    );

                    if (dayData.count > 0) {
                        rect.onclick = function () {
                            window.filterByDate(dayData.date);
                        };
                    }

                    g.appendChild(rect);
                }

                svg.appendChild(g);
            }
        };

        // Function to filter posts by date
        window.filterByDate = function(dateString) {
            const heatmap = document.getElementById("activity-heatmap");

            // If clicking the same date, clear the filter
            if (selectedDate === dateString) {
                selectedDate = null;
                heatmap?.classList.remove("is-filtering");
                // Clear any existing date filters
                const event = new CustomEvent("dateFilterChange", {
                    detail: { date: null },
                });
                window.dispatchEvent(event);
                // Reset visual feedback
                document
                    .querySelectorAll(".activity-day.selected")
                    .forEach((el) => {
                        el.classList.remove("selected");
                    });
                return;
            }

            selectedDate = dateString;
            heatmap?.classList.add("is-filtering");

            // Dispatch custom event to notify the main filtering system
            const event = new CustomEvent("dateFilterChange", {
                detail: { date: dateString },
            });
            window.dispatchEvent(event);

            // Add visual feedback to selected day
            document
                .querySelectorAll(".activity-day.selected")
                .forEach((el) => {
                    el.classList.remove("selected");
                });

            // Find and highlight the clicked day
            const clickedDay = document.querySelector(
                `[data-date="${dateString}"]`,
            );
            if (clickedDay) {
                clickedDay.classList.add("selected");
            }
        }

        // Tooltip logic
        const tooltip = document.getElementById("heatmap-tooltip");
        const svgElement = document.querySelector(".activity-heatmap-svg");

        function formatDate(dateStr) {
            const date = new Date(dateStr + "T00:00:00");
            return date.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
                year: "numeric",
            });
        }

        if (svgElement && tooltip) {
            svgElement.addEventListener("mouseover", (e) => {
                const target = e.target;
                if (target.tagName === "rect" && target.classList.contains("activity-day")) {
                    const count = parseInt(target.getAttribute("data-count") || "0");
                    const date = target.getAttribute("data-date");
                    const formattedDate = formatDate(date).toUpperCase();

                    let text = "";
                    if (count === 0) text = `Zero Operations Recorded // ${formattedDate}`;
                    else if (count === 1) text = `001 Data Commit // ${formattedDate}`;
                    else text = `${String(count).padStart(3, '0')} Data Commits // ${formattedDate}`;

                    tooltip.textContent = text;

                    // Position relative to the rect
                    const rect = target.getBoundingClientRect();
                    tooltip.style.left = `${rect.left + rect.width / 2}px`;
                    tooltip.style.top = `${rect.top - 8}px`;
                    tooltip.style.transform = "translate(-50%, -100%)";

                    tooltip.classList.remove("hidden");
                }
            });

            svgElement.addEventListener("mouseout", (e) => {
                const target = e.target;
                if (target.tagName === "rect" && target.classList.contains("activity-day")) {
                    tooltip.classList.add("hidden");
                }
            });
        }

        // Add selected class styling
        const style = document.createElement("style");
        style.textContent = `
 			.activity-day.selected {
 				stroke: #0055FF !important;
 				stroke-width: 2px !important;
 			}
            #activity-heatmap.is-filtering .activity-day:not(.selected) {
                opacity: 0.1;
            }
            #activity-heatmap.is-filtering .activity-day.selected {
                opacity: 1;
            }
 		`;
        document.head.appendChild(style);
        // Initialize from attribute or default
        const initialYear = parseInt(document.documentElement.getAttribute('data-selected-year')) || year;
        if (initialYear !== year) {
            window.updateHeatmapYear(initialYear);
        }
    </script>
</div>
