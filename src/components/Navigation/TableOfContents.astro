---

// TableOfContents.astro - Automatically generates table of contents from headings
interface Props {
    content: string;
    title: string;
    minHeadings?: number;
    headings?: Array<{ depth: number; slug: string; text: string }>;
}

const { content, title, minHeadings = 3, headings: astroHeadings } = Astro.props;

// Extract headings from Markdown content (skip frontmatter) if not provided by Astro
let headings: Array<{ level: number; id: string; text: string }> = [];

if (astroHeadings && astroHeadings.length > 0) {
    headings = astroHeadings
        .filter(h => h.depth >= 2 && h.depth <= 6)
        .map(h => ({
            level: h.depth - 1,
            id: h.slug,
            text: h.text
        }));
} else {
    const contentWithoutFrontmatter = content.replace(/^---[\s\S]*?---\n/, "");
    const headingRegex = /^(#{2,6})\s+(.+)$/gm; // H2-H6 headings
    let match;

    while ((match = headingRegex.exec(contentWithoutFrontmatter)) !== null) {
        const level = match[1].length - 1; // H2 = level 1, H3 = level 2, H4 = level 3, etc.
        const text = match[2].trim();

        // Check for {#id} in the text
        const idMatch = text.match(/\{#([^}]+)\}/);
        let id = "";
        let cleanText = text;
        if (idMatch) {
            id = idMatch[1];
            cleanText = text.replace(/\{#([^}]+)\}/, "").trim();
        } else {
            // Generate ID from text (similar to how Astro generates heading IDs)
            id = cleanText
                .toLowerCase()
                .replace(/[^\w\s-]/g, "") // Remove special characters
                .replace(/\s+/g, "-") // Replace spaces with hyphens
                .replace(/-+/g, "-") // Replace multiple hyphens with single
                .replace(/^-|-$/g, ""); // Remove leading/trailing hyphens
        }

        // Include H2-H6 headings
        headings.push({ level, id, text: cleanText });
    }
}

// Only show TOC if we have enough headings
const showTOC = headings.length >= minHeadings;

// Create nested structure for TOC
const createTOCStructure = (
    title: string,
    headings: Array<{ level: number; id: string; text: string }>,
) => {
    const toc: Array<{ id: string; text: string; children?: any[] }> = [];
    const stack: Array<{ item: any; level: number }> = [];

    // Add the post title as the first item
    const titleItem = {
        id: "",
        text: title,
        children: [],
    };
    toc.push(titleItem);
    stack.push({ item: titleItem, level: 1 });

    headings.forEach((heading) => {
        const item = { id: heading.id, text: heading.text, children: [] };

        // Find the appropriate parent level
        while (
            stack.length > 0 &&
            stack[stack.length - 1].level >= heading.level
        ) {
            stack.pop();
        }

        if (stack.length === 0) {
            toc.push(item);
        } else {
            stack[stack.length - 1].item.children!.push(item);
        }

        stack.push({ item, level: heading.level });
    });

    return toc;
};

const tocStructure = createTOCStructure(title, headings);
---
{
    showTOC && (
        <aside class="w-full">
            <nav class="toc-nav relative">
                    {tocStructure.map((item, index) => {
                        const isPostTitle = index === 0 && item.id === "";

                        return (
                            <div class="toc-item relative mb-3">
                                   <a
                                       href={isPostTitle ? "#" : `#${item.id}`}
                                       id={`toc-${item.id}`}
                                        class={`toc-link block transition-all ${
                                            isPostTitle
                                        ? "text-xs font-bold text-slate-400 dark:text-slate-500 uppercase tracking-widest mb-4 hover:text-blueprint-blue dark:hover:text-white"
                                                : "text-sm text-slate-600 dark:text-slate-400 hover:text-blueprint-blue dark:hover:text-white"
                                        }`}
                                   >
                                      {item.text}
                                  </a>
                                 {item.children &&
                                     item.children.length > 0 && (
                                         <div class="pl-3 border-l border-slate-200 dark:border-slate-800 space-y-2 mt-2">
                                             {item.children.map((child) => (
                                                 <div class="relative">
                                                      <a
                                                           href={`#${child.id}`}
                                                           id={`toc-${child.id}`}
                                                           class="toc-link block text-xs text-slate-500 dark:text-slate-500 hover:text-blueprint-blue dark:hover:text-white transition-colors"
                                                       >
                                                         {child.text}
                                                      </a>
                                                 </div>
                                             ))}
                                         </div>
                                     )}

                            </div>
                        );
                    })}
                </nav>
        </aside>
    )
}

<style>
    @reference "../../styles/global.css";

    .toc-nav {
        max-height: calc(100vh - 200px);
        overflow-y: auto;
    }

    .toc-nav::-webkit-scrollbar {
        width: 4px;
    }

    .toc-nav::-webkit-scrollbar-track {
        background: transparent;
    }

    .toc-nav::-webkit-scrollbar-thumb {
        background: rgb(203 213 225);
        border-radius: 2px;
    }

    .dark .toc-nav::-webkit-scrollbar-thumb {
        background: rgb(71 85 105);
    }

    /* Active TOC link styling */
    .toc-link.active {
        @apply text-blueprint-blue font-bold;
    }

    .dark .toc-link.active {
        @apply text-blue-500;
    }
</style>

<script>
    const tocLinks = document.querySelectorAll('.toc-link');
    const titleLink = document.querySelector('.toc-link[href="#"]');
    const headings = Array.from(document.querySelectorAll('article h2, article h3, article h4, article h5, article h6')).filter(h => h.getAttribute('id'));

    // Track which headings are currently intersecting
    const intersectingHeadings = new Set<Element>();

    function setActiveLink(link: Element | null) {
        tocLinks.forEach((l) => l.classList.remove('active'));
        if (link) {
            link.classList.add('active');
        }
    }

    // Check if we're above the first heading (only when no headings are intersecting)
    function checkTitleActive() {
        // Only highlight title if no headings are currently intersecting
        if (intersectingHeadings.size > 0) {
            return;
        }

        if (headings.length === 0) {
            setActiveLink(titleLink);
            return;
        }

        const firstHeading = headings[0];
        const firstHeadingRect = firstHeading.getBoundingClientRect();
        const offset = 120; // Account for sticky header + some padding

        // If first heading is below the offset, we're "above" it
        if (firstHeadingRect.top > offset) {
            setActiveLink(titleLink);
        }
    }

    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            const id = entry.target.getAttribute('id');
            if (entry.isIntersecting) {
                intersectingHeadings.add(entry.target);
                const activeLink = document.querySelector(`.toc-link[href="#${id}"]`);
                if (activeLink) {
                    setActiveLink(activeLink);
                }
            } else {
                intersectingHeadings.delete(entry.target);
            }
        });
    }, {
        rootMargin: '-100px 0px -66%',
        threshold: 1.0
    });

    // Observe all headings that have an ID and are within the article
    headings.forEach((heading) => {
        observer.observe(heading);
    });

    // Check scroll position to highlight title when above first heading
    let ticking = false;
    window.addEventListener('scroll', () => {
        if (!ticking) {
            window.requestAnimationFrame(() => {
                checkTitleActive();
                ticking = false;
            });
            ticking = true;
        }
    }, { passive: true });

    // Initial check
    checkTitleActive();

    // Handle clicks to avoid breaking "Back" button behavior
    document.querySelectorAll('.toc-link').forEach(link => {
        link.addEventListener('click', (e) => {
            const href = link.getAttribute('href');
            if (!href) return;

            e.preventDefault();
            const targetId = href === '#' ? null : href.substring(1);
            const targetElement = targetId ? document.getElementById(targetId) : null;

            if (targetElement || href === '#') {
                // Update URL without adding to history
                history.replaceState(null, '', href);

                if (href === '#') {
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                } else if (targetElement) {
                    // Smooth scroll to target
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            }
        });
    });
</script>
