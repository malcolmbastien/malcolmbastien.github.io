---

// TableOfContents.astro - Automatically generates table of contents from headings
interface Props {
    content: string;
    title: string;
    minHeadings?: number;
    headings?: Array<{ depth: number; slug: string; text: string }>;
}

const { content, title, minHeadings = 3, headings: astroHeadings } = Astro.props;

// Extract headings from Markdown content (skip frontmatter) if not provided by Astro
let headings: Array<{ level: number; id: string; text: string }> = [];

if (astroHeadings && astroHeadings.length > 0) {
    headings = astroHeadings
        .filter(h => h.depth >= 2 && h.depth <= 6)
        .map(h => ({
            level: h.depth - 1,
            id: h.slug,
            text: h.text
        }));
} else {
    const contentWithoutFrontmatter = content.replace(/^---[\s\S]*?---\n/, "");
    const headingRegex = /^(#{2,6})\s+(.+)$/gm; // H2-H6 headings
    let match;

    while ((match = headingRegex.exec(contentWithoutFrontmatter)) !== null) {
        const level = match[1].length - 1; // H2 = level 1, H3 = level 2, H4 = level 3, etc.
        const text = match[2].trim();

        // Check for {#id} in the text
        const idMatch = text.match(/\{#([^}]+)\}/);
        let id = "";
        let cleanText = text;
        if (idMatch) {
            id = idMatch[1];
            cleanText = text.replace(/\{#([^}]+)\}/, "").trim();
        } else {
            // Generate ID from text (similar to how Astro generates heading IDs)
            id = cleanText
                .toLowerCase()
                .replace(/[^\w\s-]/g, "") // Remove special characters
                .replace(/\s+/g, "-") // Replace spaces with hyphens
                .replace(/-+/g, "-") // Replace multiple hyphens with single
                .replace(/^-|-$/g, ""); // Remove leading/trailing hyphens
        }

        // Include H2-H6 headings
        headings.push({ level, id, text: cleanText });
    }
}

// Only show TOC if we have enough headings
const showTOC = headings.length >= minHeadings;

// Create nested structure for TOC
const createTOCStructure = (
    title: string,
    headings: Array<{ level: number; id: string; text: string }>,
) => {
    const toc: Array<{ id: string; text: string; children?: any[] }> = [];
    const stack: Array<{ item: any; level: number }> = [];

    // Add the post title as the first item
    const titleItem = {
        id: "",
        text: title,
        children: [],
    };
    toc.push(titleItem);
    stack.push({ item: titleItem, level: 1 });

    headings.forEach((heading) => {
        const item = { id: heading.id, text: heading.text, children: [] };

        // Find the appropriate parent level
        while (
            stack.length > 0 &&
            stack[stack.length - 1].level >= heading.level
        ) {
            stack.pop();
        }

        if (stack.length === 0) {
            toc.push(item);
        } else {
            stack[stack.length - 1].item.children!.push(item);
        }

        stack.push({ item, level: heading.level });
    });

    return toc;
};

const tocStructure = createTOCStructure(title, headings);
---
{
    showTOC && (
        <aside class="w-full">
            <nav class="toc-nav relative">
                    {tocStructure.map((item, index) => {
                        const isPostTitle = index === 0 && item.id === "";

                        return (
                            <div class="toc-item relative mb-3">
                                   <a
                                       href={isPostTitle ? "#" : `#${item.id}`}
                                       id={`toc-${item.id}`}
                                        class={`toc-link block transition-all ${
                                            isPostTitle
                                        ? "hidden" // Title is already shown above TOC in sidebar
                                                : "text-sm text-slate-600 dark:text-slate-400 hover:text-primary dark:hover:text-primary"
                                        }`}
                                   >
                                      {item.text}
                                  </a>
                                 {item.children &&
                                     item.children.length > 0 && (
                                         <div class="pl-3 border-l border-slate-200 dark:border-slate-800 space-y-2 mt-2">
                                             {item.children.map((child) => (
                                                 <div class="relative">
                                                      <a
                                                           href={`#${child.id}`}
                                                           id={`toc-${child.id}`}
                                                           class="toc-link block text-xs text-slate-500 dark:text-slate-500 hover:text-primary transition-colors"
                                                       >
                                                         {child.text}
                                                     </a>
                                                 </div>
                                             ))}
                                         </div>
                                     )}

                            </div>
                        );
                    })}
                </nav>
        </aside>
    )
}

<style>
    @reference "../../styles/global.css";

    .toc-nav {
        max-height: calc(100vh - 200px);
        overflow-y: auto;
    }

    .toc-nav::-webkit-scrollbar {
        width: 4px;
    }

    .toc-nav::-webkit-scrollbar-track {
        background: transparent;
    }

    .toc-nav::-webkit-scrollbar-thumb {
        background: rgb(203 213 225);
        border-radius: 2px;
    }

    .dark .toc-nav::-webkit-scrollbar-thumb {
        background: rgb(71 85 105);
    }

    /* Active TOC link styling */
    .toc-link.active {
        @apply text-blueprint-blue font-bold;
    }

    .dark .toc-link.active {
        @apply text-blue-500;
    }
</style>

<script>
    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            const id = entry.target.getAttribute('id');
            if (entry.isIntersecting) {
                document.querySelectorAll('.toc-link').forEach((link) => {
                    link.classList.remove('active');
                });
                const activeLink = document.querySelector(`.toc-link[href="#${id}"]`);
                if (activeLink) {
                    activeLink.classList.add('active');
                }
            }
        });
    }, {
        rootMargin: '-100px 0px -66%',
        threshold: 1.0
    });

    // Observe all headings that have an ID and are within the article
    document.querySelectorAll('article h2, article h3, article h4, article h5, article h6').forEach((heading) => {
        if (heading.getAttribute('id')) {
            observer.observe(heading);
        }
    });

    // Handle clicks to avoid breaking "Back" button behavior
    document.querySelectorAll('.toc-link').forEach(link => {
        link.addEventListener('click', (e) => {
            const href = link.getAttribute('href');
            if (!href || href === '#') return;
            
            e.preventDefault();
            const targetId = href.substring(1);
            const targetElement = document.getElementById(targetId);
            
            if (targetElement) {
                // Update URL without adding to history
                history.replaceState(null, '', href);
                
                // Smooth scroll to target
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });
</script>
