---

// TableOfContents.astro - Automatically generates table of contents from headings
interface Props {
    content?: string;
    title?: string;
    minHeadings?: number;
    headings?: Array<{ depth: number; slug: string; text: string }>;
    sectionIds?: Array<{ id: string; text: string }>;
}

const { content, title = "Table of Contents", minHeadings = 2, headings: astroHeadings, sectionIds } = Astro.props;

let headings: Array<{ level: number; id: string; text: string }> = [];

// If sectionIds are provided directly (for pages like colophon/about), use those
if (sectionIds && sectionIds.length > 0) {
    headings = sectionIds.map((section, index) => ({
        level: index === 0 ? 1 : 2,
        id: section.id,
        text: section.text
    }));
} else if (astroHeadings && astroHeadings.length > 0) {
    // Use provided headings from Astro
    headings = astroHeadings
        .filter(h => h.depth >= 2 && h.depth <= 6)
        .map(h => ({
            level: h.depth - 1,
            id: h.slug,
            text: h.text
        }));
} else if (content) {
    // Extract headings from Markdown content (skip frontmatter)
    const contentWithoutFrontmatter = content.replace(/^---[\s\S]*?---\n/, "");
    const headingRegex = /^(#{2,6})\s+(.+)$/gm;
    let match;

    while ((match = headingRegex.exec(contentWithoutFrontmatter)) !== null) {
        const level = match[1].length - 1;
        const text = match[2].trim();

        const idMatch = text.match(/\{#([^}]+)\}/);
        let id = "";
        let cleanText = text;
        if (idMatch) {
            id = idMatch[1];
            cleanText = text.replace(/\{#([^}]+)\}/, "").trim();
        } else {
            id = cleanText
                .toLowerCase()
                .replace(/[^\w\s-]/g, "")
                .replace(/\s+/g, "-")
                .replace(/-+/g, "-")
                .replace(/^-|-$/g, "");
        }

        headings.push({ level, id, text: cleanText });
    }
}

// Only show TOC if we have enough headings
const showTOC = headings.length >= minHeadings;

// Create nested structure for TOC
const createTOCStructure = (
    headings: Array<{ level: number; id: string; text: string }>,
) => {
    const toc: Array<{ id: string; text: string; children?: any[] }> = [];
    const stack: Array<{ item: any; level: number }> = [];

    headings.forEach((heading) => {
        const item = { id: heading.id, text: heading.text, children: [] };

        while (
            stack.length > 0 &&
            stack[stack.length - 1].level >= heading.level
        ) {
            stack.pop();
        }

        if (stack.length === 0) {
            toc.push(item);
        } else {
            stack[stack.length - 1].item.children!.push(item);
        }

        stack.push({ item, level: heading.level });
    });

    return toc;
};

const tocStructure = createTOCStructure(headings);
---
{
    showTOC && (
        <aside class="w-full pb-6 border-b border-slate-100 dark:border-slate-800">
            <h3 class="text-sm font-bold tracking-widest text-slate-500 mb-4">{title}</h3>
            <nav class="toc-nav relative">
                    {tocStructure.map((item) => (
                        <div class="toc-item relative mb-2">
                            <a
                                href={`#${item.id}`}
                                id={`toc-${item.id}`}
                                class="toc-link block text-sm text-slate-600 dark:text-slate-400 hover:text-primary dark:hover:text-blue-400 transition-colors"
                            >
                                {item.text}
                            </a>
                            {item.children && item.children.length > 0 && (
                                <div class="pl-3 border-l border-slate-200 dark:border-slate-800 space-y-1.5 mt-1.5 mb-3">
                                    {item.children.map((child) => (
                                        <div class="relative">
                                            <a
                                                href={`#${child.id}`}
                                                id={`toc-${child.id}`}
                                                class="toc-link block text-xs text-slate-500 dark:text-slate-500 hover:text-primary dark:hover:text-blue-400 transition-colors"
                                            >
                                                {child.text}
                                            </a>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    ))}
                </nav>
        </aside>
    )
}

<style>
    @reference "../../styles/global.css";

    .toc-nav {
        max-height: calc(100vh - 200px);
        overflow-y: auto;
    }

    .toc-nav::-webkit-scrollbar {
        width: 4px;
    }

    .toc-nav::-webkit-scrollbar-track {
        background: transparent;
    }

    .toc-nav::-webkit-scrollbar-thumb {
        background: rgb(203 213 225);
        border-radius: 2px;
    }

    .dark .toc-nav::-webkit-scrollbar-thumb {
        background: rgb(71 85 105);
    }

    /* Active TOC link styling */
    .toc-link.active {
        @apply text-primary font-bold;
    }

    .dark .toc-link.active {
        @apply text-blue-400;
    }
</style>

<script>
    const tocLinks = document.querySelectorAll('.toc-link');
    const headings = Array.from(document.querySelectorAll('section[id], div[id], header[id]')).filter(h => h.getAttribute('id'));

    // Track which headings are currently intersecting
    const intersectingHeadings = new Set<Element>();

    function setActiveLink(link: Element | null) {
        tocLinks.forEach((l) => l.classList.remove('active'));
        if (link) {
            link.classList.add('active');
        }
    }

    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            const id = entry.target.getAttribute('id');
            if (entry.isIntersecting) {
                intersectingHeadings.add(entry.target);
                const activeLink = document.querySelector(`.toc-link[href="#${id}"]`);
                if (activeLink) {
                    setActiveLink(activeLink);
                }
            } else {
                intersectingHeadings.delete(entry.target);
            }
        });
    }, {
        rootMargin: '-100px 0px -66%',
        threshold: 1.0
    });

    // Observe all headings that have an ID
    headings.forEach((heading) => {
        observer.observe(heading);
    });

    // Handle clicks to avoid breaking "Back" button behavior
    document.querySelectorAll('.toc-link').forEach(link => {
        link.addEventListener('click', (e) => {
            const href = link.getAttribute('href');
            if (!href) return;

            e.preventDefault();
            const targetId = href.substring(1);
            const targetElement = document.getElementById(targetId);

            if (targetElement) {
                // Update URL without adding to history
                history.replaceState(null, '', href);

                // Smooth scroll to target
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });
</script>
