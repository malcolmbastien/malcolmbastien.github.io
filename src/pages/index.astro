---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "../layouts/Layout.astro";
import ActivityHeatmap from "../components/Profile/ActivityHeatmap.astro";
import ProfileHeader from "../components/Profile/ProfileHeader.astro";
import YearNavigation from "../components/YearNavigation.astro";
import PostTimeline from "../components/PostTimeline.astro";
import SiteFooter from "../components/SiteFooter.astro";
import Search from "../components/Navigation/Search.astro";
import { getBatchFileDates } from "../lib/git-history";

const allPosts = await getCollection("posts");
const batchDates = await getBatchFileDates();

// Fetch git dates for all posts to create timeline events
const postsWithDates = allPosts.map((post) => {
    const filePath = `src/content/posts/${post.id}`;
    const dates = batchDates.get(filePath);
    const created = dates?.created;
    const updated = dates?.updated;

    return {
        ...post,
        displayDate: post.data.publishedDate || created || new Date(),
        updatedDate: updated || created || new Date(),
    };
});

// Create timeline events
const events: any[] = [];
postsWithDates.forEach((post) => {
    // Add creation event
    events.push({
        type: "created",
        post,
        date: post.displayDate,
        title: post.data.title,
    });

    // Add update event if updated significantly later
    if (
        post.updatedDate.getTime() >
        post.displayDate.getTime() + 1000 * 60 * 60
    ) {
        // More than 1 hour
        events.push({
            type: "updated",
            post,
            date: post.updatedDate,
            title: post.data.title,
        });
    }
});

// Aggregate events: group multiple updates to same post within short time
const aggregatedEvents: any[] = [];
const eventGroups = new Map();

events.forEach((event) => {
    const key = `${event.post.slug}-${event.type}`;
    if (!eventGroups.has(key)) {
        eventGroups.set(key, []);
    }
    eventGroups.get(key).push(event);
});

eventGroups.forEach((group) => {
    if (group.length === 1) {
        aggregatedEvents.push(group[0]);
    } else {
        // Multiple events, aggregate them
        const firstEvent = group[0];
        const lastEvent = group[group.length - 1];
        aggregatedEvents.push({
            ...firstEvent,
            count: group.length,
            date: lastEvent.date, // Use the most recent date
        });
    }
});

// Sort events by date descending
const sortedEvents = aggregatedEvents.sort(
    (a, b) => b.date.valueOf() - a.date.valueOf(),
);

// Generate all months from earliest event to now
const earliestDate =
    sortedEvents.length > 0
        ? sortedEvents[sortedEvents.length - 1]?.date || new Date()
        : new Date();
const latestDate =
    sortedEvents.length > 0 ? sortedEvents[0]?.date || new Date() : new Date();

const allMonths: Array<{
    key: string;
    date: Date;
    hasActivity: boolean;
}> = [];

const currentDate = new Date();
currentDate.setDate(1); // Start from first day of current month
currentDate.setHours(0, 0, 0, 0);

const endDate = new Date(earliestDate);
endDate.setDate(1);
endDate.setHours(0, 0, 0, 0);

// Group events by month for quick lookup
const eventsByMonthKey = new Map<string, any[]>();
sortedEvents.forEach((event) => {
    const monthKey = event.date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    if (!eventsByMonthKey.has(monthKey)) {
        eventsByMonthKey.set(monthKey, []);
    }
    eventsByMonthKey.get(monthKey)?.push(event);
});

// Generate all months from current to earliest
while (currentDate >= endDate) {
    const monthKey = currentDate.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    allMonths.push({
        key: monthKey,
        date: new Date(currentDate),
        hasActivity: eventsByMonthKey.has(monthKey),
    });

    // Move to previous month
    currentDate.setMonth(currentDate.getMonth() - 1);
}

// Collect years data for sidebar
const yearsData = new Map();
sortedEvents.forEach((event) => {
    const year = event.date.getFullYear();
    const month = event.date.getMonth();

    if (!yearsData.has(year)) {
        yearsData.set(year, { count: 0, months: new Set() });
    }
    yearsData.get(year).count++;
    yearsData.get(year).months.add(month);
});

// Convert to array and sort by year descending
const yearsArray = Array.from(yearsData.entries());
yearsArray.sort((a, b) => b[0] - a[0]);
const sortedYears = yearsArray.map(([year, data]) => ({
    year: year as number,
    count: data.count as number,
    months: (Array.from(data.months) as number[]).sort((a, b) => b - a), // months descending within year
}));

// Default to current year for heatmap
const currentYearValue = new Date().getFullYear();
---

<Layout
    title="Sprout - A Digital Garden"
    description="A digital garden of thoughts and ideas. Explore seeds, sprouts, and trees of knowledge in this ever-growing collection of writings."
    type="website"
>
    <main class="max-w-7xl mx-auto p-4 md:p-8">
        <ProfileHeader />

        <!-- Wide Search Bar - Centered above content for better usability -->
        <div class="max-w-2xl mx-auto w-full mb-10">
            <div
                class="bg-white dark:bg-[#121812] border border-slate-200 dark:border-slate-800 rounded-2xl shadow-sm p-1.5 px-4 focus-within:ring-2 focus-within:ring-emerald-500/20 focus-within:border-emerald-500 transition-all"
            >
                <Search />
            </div>
        </div>

        <div class="flex flex-col lg:flex-row gap-8">
            <!-- Left Column: Activity Heatmap and Timeline -->
            <div class="flex-1 min-w-0 space-y-6">
                <ActivityHeatmap
                    year={currentYearValue}
                    events={sortedEvents as any}
                />
                <PostTimeline
                    sortedEvents={sortedEvents}
                    allMonths={allMonths}
                    eventsByMonthKey={eventsByMonthKey}
                />
            </div>

            <!-- Right Column: Years Navigation (Scrollable if long) -->
            <div
                class="w-full lg:w-64 shrink-0 lg:sticky lg:top-8 lg:max-h-[calc(100vh-4rem)] lg:overflow-y-auto custom-sidebar-scroll z-30 pb-10"
            >
                <YearNavigation sortedYears={sortedYears as any} />
            </div>
        </div>
        <SiteFooter />
    </main>
</Layout>

<style is:global>
    @reference "../styles/global.css";

    /* Styling for the scrollable sidebar */
    .custom-sidebar-scroll {
        scrollbar-width: thin;
        scrollbar-color: #e2e8f0 transparent;
    }
    .dark .custom-sidebar-scroll {
        scrollbar-color: #1e293b transparent;
    }
    .custom-sidebar-scroll::-webkit-scrollbar {
        width: 4px;
    }
    .custom-sidebar-scroll::-webkit-scrollbar-track {
        background: transparent;
    }
    .custom-sidebar-scroll::-webkit-scrollbar-thumb {
        @apply bg-slate-200 dark:bg-slate-800 rounded-full;
    }
</style>

<script>
    declare global {
        interface Window {
            updateHeatmapYear?: (year: number) => void;
        }
    }

    const buttons = document.querySelectorAll("[data-status]");
    const tagButtons = document.querySelectorAll("[data-tag]");
    const eventTypeButtons = document.querySelectorAll("[data-event-type]");
    const timelineEvents = document.querySelectorAll(".timeline-event");
    const noResults = document.getElementById("no-results");

    let currentFilter = "all";
    let currentTag = "";
    let currentEventType = "all";
    let currentYear = new Date().getFullYear().toString();
    let searchQuery = "";
    let currentDateFilter: string | null = null;

    function updateDisplay() {
        let visibleCount = 0;

        // Re-query to include dynamically added events
        const allTimelineEvents = document.querySelectorAll(".timeline-event");

        allTimelineEvents.forEach((event) => {
            const htmlEvent = event as HTMLElement;
            const status = htmlEvent.dataset.status;
            const title = htmlEvent.dataset.title || "";
            const summary = htmlEvent.dataset.summary || "";
            const tags = htmlEvent.dataset.tags || "";
            const eventYear = htmlEvent.dataset.eventYear || "";
            const eventType = htmlEvent.dataset.eventType;

            const matchesFilter =
                currentFilter === "all" || status === currentFilter;
            const matchesTag = currentTag === "" || tags.includes(currentTag);
            const matchesEventType =
                currentEventType === "all" || eventType === currentEventType;
            const matchesYear =
                currentYear === "all" || eventYear === currentYear;
            const matchesSearch =
                title.includes(searchQuery) ||
                summary.includes(searchQuery) ||
                tags.includes(searchQuery);

            // If filtering by a specific date from the heatmap
            const eventDate = htmlEvent.dataset.created || "";
            const matchesDate =
                currentDateFilter === null || eventDate === currentDateFilter;

            if (
                matchesFilter &&
                matchesTag &&
                matchesEventType &&
                matchesYear &&
                matchesSearch &&
                matchesDate
            ) {
                htmlEvent.style.display = "flex";
                visibleCount++;
            } else {
                htmlEvent.style.display = "none";
            }
        });

        // Show/hide month sections based on their visible events
        document.querySelectorAll(".month-section").forEach((section) => {
            const htmlSection = section as HTMLElement;
            const eventsInSection = Array.from(
                htmlSection.querySelectorAll(".timeline-event"),
            );
            const hasVisibleEvent = eventsInSection.some(
                (e) => (e as HTMLElement).style.display !== "none",
            );

            if (hasVisibleEvent) {
                htmlSection.style.display = "block";
            } else {
                htmlSection.style.display = "none";
            }
        });

        // Ensure containers are not blocking visibility if they contain visible things
        const hiddenMonthsContainer = document.getElementById("hidden-months");
        if (hiddenMonthsContainer) {
            if (
                currentFilter !== "all" ||
                currentTag !== "" ||
                currentEventType !== "all" ||
                currentYear !== "all" ||
                searchQuery !== "" ||
                currentDateFilter !== null
            ) {
                hiddenMonthsContainer.classList.remove("hidden");
                const showMoreButton = document.getElementById(
                    "show-more-activity",
                );
                if (showMoreButton) showMoreButton.style.display = "none";
            }
        }

        if (noResults) {
            if (visibleCount === 0) noResults.classList.remove("hidden");
            else noResults.classList.add("hidden");
        }
    }

    buttons.forEach((button) => {
        button.addEventListener("click", () => {
            const status = (button as HTMLElement).dataset.status || "all";
            if (currentFilter === status) {
                button.classList.remove("active");
                currentFilter = "all";
            } else {
                buttons.forEach((btn) => btn.classList.remove("active"));
                button.classList.add("active");
                currentFilter = status;
            }
            updateDisplay();
        });
    });

    tagButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const tag = (button as HTMLElement).dataset.tag || "";
            if (currentTag === tag) {
                button.classList.remove("active");
                currentTag = "";
            } else {
                tagButtons.forEach((btn) => btn.classList.remove("active"));
                button.classList.add("active");
                currentTag = tag;
            }
            updateDisplay();
        });
    });

    eventTypeButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const eventType =
                (button as HTMLElement).dataset.eventType || "all";
            if (currentEventType === eventType) {
                button.classList.remove("active");
                currentEventType = "all";
            } else {
                eventTypeButtons.forEach((btn) =>
                    btn.classList.remove("active"),
                );
                button.classList.add("active");
                currentEventType = eventType;
            }
            updateDisplay();
        });
    });

    // Year and Month navigation
    const yearButtons = document.querySelectorAll(".year-btn");
    const monthButtons = document.querySelectorAll(".month-btn");

    yearButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const year = (button as HTMLElement).dataset.year || "all";
            const yearItem = button.closest(".year-item") as HTMLElement;
            const monthSubmenu = yearItem?.querySelector(
                ".month-submenu",
            ) as HTMLElement;

            if (currentYear === year) {
                if (monthSubmenu) {
                    monthSubmenu.classList.toggle("hidden");
                }
            } else {
                yearButtons.forEach((btn) => {
                    btn.classList.remove("active");
                    const item = btn.closest(".year-item");
                    const submenu = item?.querySelector(".month-submenu");
                    if (submenu) submenu.classList.add("hidden");
                });
                button.classList.add("active");
                currentYear = year;

                if (monthSubmenu) {
                    monthSubmenu.classList.remove("hidden");
                }

                if (window.updateHeatmapYear) {
                    window.updateHeatmapYear(parseInt(year));
                }

                // Scroll to top of Activity Heatmap when a NEW year is selected
                const heatmap = document.getElementById("activity-heatmap");
                if (heatmap) {
                    heatmap.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                    });
                }
            }
            updateDisplay();
        });
    });

    monthButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const monthKey = (button as HTMLElement).dataset.month || "";
            const year = (button as HTMLElement).dataset.year || "all";

            if (currentYear !== year) {
                const yearBtn = document.querySelector(
                    `.year-btn[data-year="${year}"]`,
                );
                if (yearBtn) (yearBtn as HTMLElement).click();
            }

            const monthSection = document.querySelector(
                `.month-section[data-month="${monthKey}"]`,
            );
            if (monthSection) {
                setTimeout(() => {
                    monthSection.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                    });
                }, 50);
            }
        });
    });

    // Listen for date filter changes from activity heatmap
    window.addEventListener("dateFilterChange", (e: any) => {
        currentDateFilter = e.detail.date;
        updateDisplay();
    });

    // Listen for display updates when new months are revealed
    window.addEventListener("updateDisplayNeeded", () => {
        updateDisplay();
    });

    // Prevent any interference with timeline event clicks
    document.querySelectorAll(".timeline-event").forEach((event) => {
        event.addEventListener(
            "click",
            (e) => {
                e.stopPropagation();
            },
            true,
        );
        event.addEventListener("focus", (e) => e.stopPropagation(), true);
        event.addEventListener("blur", (e) => e.stopPropagation(), true);
    });

    // Check URL params for initial tag filter
    const urlParams = new URLSearchParams(window.location.search);
    const tagParam = urlParams.get("tag");
    if (tagParam) {
        currentTag = tagParam;
        const targetTagBtn = Array.from(tagButtons).find(
            (btn) => (btn as HTMLElement).dataset.tag === tagParam,
        );
        if (targetTagBtn) {
            targetTagBtn.classList.add("active");
            tagButtons.forEach((btn) => {
                if (btn !== targetTagBtn) btn.classList.remove("active");
            });
        }
        updateDisplay();
    }

    // Automatically select current year on initial load
    window.addEventListener("DOMContentLoaded", () => {
        const yearStr = new Date().getFullYear().toString();
        const yearBtn = document.querySelector(
            `.year-btn[data-year="${yearStr}"]`,
        );

        currentYear = "all";

        if (yearBtn) {
            (yearBtn as HTMLElement).click();
        } else {
            const allYearBtns = document.querySelectorAll(".year-btn");
            if (allYearBtns.length > 0) {
                (allYearBtns[0] as HTMLElement).click();
            }
        }
    });
</script>
