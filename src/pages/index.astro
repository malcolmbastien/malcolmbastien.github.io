---
import { getCollection } from "astro:content";
import Layout from "../layouts/Layout.astro";
import ActivityHeatmap from "../components/Profile/ActivityHeatmap.astro";
import Header from "../components/Profile/Header.astro";
import YearNavigation from "../components/YearNavigation.astro";
import NoteTimeline from "../components/NoteTimeline.astro";
import SiteFooter from "../components/SiteFooter.astro";
import GardenStats from "../components/Profile/GardenStats.astro";
import SocialLinks from "../components/Profile/SocialLinks.astro";
import TopicFocus from "../components/Profile/TopicFocus.astro";

import { getBatchFileDates, type FileDates } from "../lib/git-history";
import AboutAuthor from "../components/AboutAuthor.astro";
import { getStageData } from "../lib/theme";

const allNotes = await getCollection("notes");
const batchDates = (await getBatchFileDates()) as Map<string, FileDates>;

// Fetch git dates for all notes to create timeline events
const notesWithDates = allNotes.map((note) => {
    const id = note.id;
    const dates = batchDates.get(`src/content/notes/${id}`) ||
                  batchDates.get(`src/content/notes/${id}.md`) ||
                  batchDates.get(`src/content/notes/${id}.mdx`);

    const created = dates?.created;
    const allGitDates = dates?.allDates || new Set<string>();

    const displayDate = note.data.publishedDate || created;

    return {
        ...note,
        displayDate,
        allGitDates,
    };
}).filter((note): note is typeof note & { displayDate: Date } => !!note.displayDate); // Only show notes that have a valid date from frontmatter or git

// Create timeline events
const events: any[] = [];
notesWithDates.forEach((note) => {
    const displayDate = note.displayDate as Date;
    const displayDateStr = displayDate.toISOString().split("T")[0];

    // Add creation event
    events.push({
        type: "created",
        note,
        date: displayDate,
        title: note.data.title,
    });

    // Add update events for all other unique git dates
    note.allGitDates.forEach((dateStr: string) => {
        // Only add as update if it's a different day than creation
        if (dateStr !== displayDateStr) {
            // We use 12:00 PM for these historical updates to ensure they sort reasonably
            // or we could try to find the actual time, but dateStr is just the day
            const updateDate = new Date(dateStr + "T12:00:00");
            events.push({
                type: "updated",
                note,
                date: updateDate,
                title: note.data.title,
            });
        }
    });
});

// Aggregate events: group multiple updates to same note within short time
const aggregatedEvents: any[] = [];
const eventGroups = new Map();

events.forEach((event) => {
    // Group by slug, type, AND date (day) to ensure at most one event per note per day per type
    const dateStr = (event.date as Date).toISOString().split("T")[0];
    const key = `${event.note.slug}-${event.type}-${dateStr}`;
    if (!eventGroups.has(key)) {
        eventGroups.set(key, []);
    }
    eventGroups.get(key).push(event);
});

eventGroups.forEach((group) => {
    if (group.length === 1) {
        aggregatedEvents.push(group[0]);
    } else {
        // Multiple events, aggregate them
        const firstEvent = group[0];
        const lastEvent = group[group.length - 1];
        aggregatedEvents.push({
            ...firstEvent,
            count: group.length,
            date: lastEvent.date, // Use the most recent date
        });
    }
});

// Sort events by date descending
const sortedEvents = aggregatedEvents.sort(
    (a, b) => b.date.valueOf() - a.date.valueOf(),
);

// Identify which events to collapse in the timeline (show only one update per note per month)
const creationsInMonth = new Set<string>();
sortedEvents.forEach((e) => {
    if (e.type === "created") {
        const monthKey = e.date.toLocaleDateString("en-US", {
            year: "numeric",
            month: "long",
        });
        creationsInMonth.add(`${e.note.slug}-${monthKey}`);
    }
});

const seenUpdateInMonth = new Set<string>();
sortedEvents.forEach((event) => {
    const monthKey = event.date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    const noteKey = `${event.note.slug}-${monthKey}`;

    if (event.type === "created") {
        event.isCollapsed = false;
    } else {
        // It's an update - collapse if there's a creation or a later update in the same month
        if (creationsInMonth.has(noteKey) || seenUpdateInMonth.has(noteKey)) {
            event.isCollapsed = true;
        } else {
            event.isCollapsed = false;
            seenUpdateInMonth.add(noteKey);
        }
    }
});

// Generate all months from earliest event to now
const earliestDate =
    sortedEvents.length > 0
        ? sortedEvents[sortedEvents.length - 1]?.date || new Date()
        : new Date();

const allMonths: Array<{
    key: string;
    date: Date;
    hasActivity: boolean;
}> = [];

const currentDate = new Date();
currentDate.setDate(1); // Start from first day of current month
currentDate.setHours(0, 0, 0, 0);

const endDate = new Date(earliestDate);
endDate.setDate(1);
endDate.setHours(0, 0, 0, 0);

// Group events by month for quick lookup
const eventsByMonthKey = new Map<string, any[]>();
sortedEvents.forEach((event) => {
    const monthKey = event.date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    if (!eventsByMonthKey.has(monthKey)) {
        eventsByMonthKey.set(monthKey, []);
    }
    eventsByMonthKey.get(monthKey)?.push(event);
});

// Generate all months from current to earliest
while (currentDate >= endDate) {
    const monthKey = currentDate.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    allMonths.push({
        key: monthKey,
        date: new Date(currentDate),
        hasActivity: eventsByMonthKey.has(monthKey),
    });

    // Move to previous month
    currentDate.setMonth(currentDate.getMonth() - 1);
}

// Collect years data for sidebar
const yearsData = new Map();
sortedEvents.forEach((event) => {
    const year = event.date.getFullYear();
    const month = event.date.getMonth();

    if (!yearsData.has(year)) {
        yearsData.set(year, { count: 0, months: new Set(), uniqueNotes: new Set() });
    }
    yearsData.get(year).count++; // Total activity for dots
    yearsData.get(year).months.add(month);
    yearsData.get(year).uniqueNotes.add(event.note.id); // Unique notes for the count label
});

// Convert to array and sort by year descending
const yearsArray = Array.from(yearsData.entries());
yearsArray.sort((a, b) => b[0] - a[0]);
const sortedYears = yearsArray.map(([year, data]) => ({
    year: year as number,
    count: data.uniqueNotes.size, // Number of unique notes touched
    activityCount: data.count as number, // Total activity volume
    months: (Array.from(data.months) as number[]).sort((a, b) => b - a), // months descending within year
}));

// Identify pinned notes
const pinnedNotes = allNotes.filter((note) => (note.data as any).pinned === true);

// Get latest 3 created notes (that aren't pinned)
const latestCreations = notesWithDates
    .filter(p => !!p.displayDate && !pinnedNotes.some(pinned => pinned.id === p.id))
    .sort((a, b) => b.displayDate!.valueOf() - a.displayDate!.valueOf())
    .slice(0, 3);



// Compute note counts by stage
const publishedNotes = allNotes.filter((note) => note.data);
const counts = {
    all: publishedNotes.length,
    seed: publishedNotes.filter((n: any) => n.data.stage === "seed").length,
    sprout: publishedNotes.filter((n: any) => n.data.stage === "sprout")
        .length,
    evergreen: publishedNotes.filter((n: any) => n.data.stage === "evergreen").length,
};

// Default to current year for heatmap
const currentYearValue = new Date().getFullYear();
---

<Layout
    title="Malcolm Bastien - Flow Focused"
    description="A digital garden of thoughts and ideas. Explore seeds, sprouts, and evergreens of knowledge in this ever-growing collection of writings."
    type="website"
>
    <style slot="head" is:inline set:html={
        sortedYears.map(y => `
        /* Instant CSS-driven filtering */
        html[data-selected-year="${y.year}"] .timeline-event:not([data-event-year="${y.year}"]),
        html[data-selected-year="${y.year}"] .month-section:not([data-year="${y.year}"]) {
            display: none !important;
        }

        /* Initial batching protection (before JS takes over) */
        html:not(.js-initialized)[data-selected-year="${y.year}"] .timeline-event[data-event-year="${y.year}"][data-is-initial-batch="false"] {
            display: none !important;
        }
        html:not(.js-initialized)[data-selected-year="${y.year}"] .month-section[data-year="${y.year}"]:not(:has(.timeline-event[data-event-year="${y.year}"][data-is-initial-batch="true"])) {
            display: none !important;
        }

        /* Instant Sidebar Highlighting */
        html[data-selected-year="${y.year}"] .year-btn[data-year="${y.year}"] {
            color: black !important;
        }
        html.dark[data-selected-year="${y.year}"] .year-btn[data-year="${y.year}"] {
            color: white !important;
        }
        html[data-selected-year="${y.year}"] .year-item:has(.year-btn[data-year="${y.year}"]) .month-submenu {
            display: flex !important;
        }
        `).join('')
    } />
    <script slot="head" is:inline>
        // Set the selected year as early as possible in the HEAD to allow for CSS-driven filtering
        (function() {
            const savedYear = localStorage.getItem('selectedYear');
            const currentYear = new Date().getFullYear().toString();
            document.documentElement.setAttribute('data-selected-year', savedYear || currentYear);
        })();
    </script>
    <main class="max-w-7xl mx-auto px-6 py-12" data-pagefind-ignore>
        <Header currentPath={Astro.url.pathname}>
            <ActivityHeatmap
                slot="heatmap"
                year={currentYearValue}
                events={sortedEvents as any}
            />
        </Header>

        <div class="border-b  border-slate-200 dark:border-slate-800 w-full mb-10"></div>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-12">
            <!-- Year Navigation (1 col) -->
            <aside class="lg:col-span-1 hidden lg:block border-r border-slate-200 dark:border-slate-800 pr-4">
                <div class="sticky top-24">
                    <YearNavigation sortedYears={sortedYears as any} />
                </div>
            </aside>

            <!-- Main Content (8 cols) -->
            <div class="lg:col-span-8 space-y-12">
                {
                    pinnedNotes.length > 0 && (
                                <section>
                                    <div class="flex items-center gap-2 mb-6">
                                        <span class="material-symbols-outlined text-slate-400 text-sm">push_pin</span>
                                        <h2 class="text-xs font-bold uppercase tracking-[0.2em] text-slate-400">Pinned Notes</h2>
                                    </div>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                        {pinnedNotes.map((note) => (
                                            <article class="bg-white dark:bg-slate-800 p-6 rounded-xl border border-slate-200 dark:border-slate-700 shadow-sm group hover:shadow-md transition-all relative">
                                                <div class="flex justify-between items-start mb-4">
                                                    <span class={`text-[10px] font-bold uppercase tracking-widest px-2 py-1 rounded ${getStageData(note.data.stage).colors.badge}`}>
                                                        {note.data.stage}
                                                    </span>
                                                    <span class="text-[10px] text-slate-400 font-medium italic">Pinned</span>
                                                </div>
                                                <h3 class="text-xl font-bold text-black dark:text-white mb-2 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">
                                                    <a href={`/notes/${note.id.replace('.md', '')}`} class="after:absolute after:inset-0">
                                                        {note.data.title}
                                                    </a>
                                                </h3>
                                        {note.data.summary && (
                                            <p class="text-sm text-slate-500 dark:text-slate-400 font-body line-clamp-2">
                                                {note.data.summary}
                                            </p>
                                        )}
                                    </article>
                                ))}
                            </div>
                        </section>
                    )
                }

                <div class="border-b  border-slate-200 dark:border-slate-800 w-full"></div>

                <NoteTimeline
                    sortedEvents={sortedEvents}
                    allMonths={allMonths}
                    eventsByMonthKey={eventsByMonthKey}
                    initialYear={currentYearValue.toString()}
                />
            </div>

            <!-- Sidebar (3 cols) -->
            <aside class="lg:col-span-3 space-y-10">
                <!-- Latest Creations -->
                <section class="bg-white dark:bg-slate-800 p-6 rounded-xl border border-slate-200 dark:border-slate-700 shadow-sm">
                    <h3 class="text-xs font-bold uppercase tracking-[0.2em] text-slate-400 mb-6">Latest Creations</h3>
                    <div class="space-y-4">
                        {latestCreations.map((note) => (
                            <div class="group cursor-pointer relative">
                                <div class="flex justify-between items-center mb-1">
                                    <span class={`text-[10px] font-bold uppercase px-2 py-1 rounded ${getStageData(note.data.stage).colors.badge}`}>{note.data.stage}</span>
                                    <span class="text-[10px] text-slate-400">
                                        {note.displayDate!.toLocaleDateString("en-US", { month: 'short', day: 'numeric' })}
                                    </span>
                                </div>
                                <p class="text-sm font-semibold text-black dark:text-white group-hover:text-blue-500 dark:group-hover:text-blue-400 transition-colors">
                                    <a href={`/notes/${note.id.replace('.md', '')}`} class="after:absolute after:inset-0">
                                        {note.data.title}
                                    </a>
                                </p>
                            </div>
                        ))}
                    </div>
                </section>

                <AboutAuthor />

                <GardenStats counts={counts} />

                <!-- Search -->
                <section class="bg-white dark:bg-slate-800 p-6 rounded-xl border border-slate-200 dark:border-slate-700 shadow-sm">
                    <h3 class="text-xs font-bold uppercase tracking-[0.2em] text-slate-400 mb-4">Search</h3>
                    <div class="relative">
                        <span class="material-symbols-outlined absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 text-sm">search</span>
                        <a href="/search" class="block w-full bg-slate-50 dark:bg-slate-900 border-none rounded-lg pl-10 pr-4 py-2 text-sm text-slate-400 transition-all">
                            Search notes...
                        </a>
                    </div>
                </section>

                <TopicFocus />

                <SocialLinks />
            </aside>
        </div>
    </main>
    <SiteFooter />
</Layout>

<style is:global>
    @reference "../styles/global.css";

    /* CSS-driven filtering for instant load */
    .timeline-event.hidden-by-filter {
        display: none !important;
    }
</style>

<script>
    declare global {
        interface Window {
            updateHeatmapYear?: (year: number) => void;
        }
    }

    const noResults = document.getElementById("no-results");

    if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }

    let currentFilter = "all";
    let currentTopic = "";
    let currentEventType = "all";
    let currentYear = document.documentElement.getAttribute('data-selected-year') || new Date().getFullYear().toString();
    let currentDateFilter: string | null = null;
    let itemsToShow = 10;

    const showMoreButton = document.getElementById("show-more-activity");

    function updateDisplay() {
        let totalMatchingCount = 0;
        let visibleCount = 0;

        const allTimelineEvents = document.querySelectorAll("#timeline .timeline-event");

        allTimelineEvents.forEach((event) => {
            const htmlEvent = event as HTMLElement;
            const stage = htmlEvent.dataset.stage;
            const eventYear = htmlEvent.dataset.eventYear || "";
            const eventType = htmlEvent.dataset.eventType;

            const matchesFilter =
                currentFilter === "all" || stage === currentFilter;
            const matchesTopic = currentTopic === "" || (htmlEvent.dataset.topics || "").includes(currentTopic);
            const matchesEventType =
                currentEventType === "all" || eventType === currentEventType;

            const matchesYear =
                currentYear === "all" || eventYear === currentYear;

            const isCollapsed = htmlEvent.dataset.isCollapsed === "true";

            const eventDate = htmlEvent.dataset.created || "";
            const matchesDate =
                currentDateFilter === null || eventDate === currentDateFilter;

            const visibilityByCollapse = currentDateFilter !== null ? matchesDate : !isCollapsed;

            if (
                matchesFilter &&
                matchesTopic &&
                matchesEventType &&
                matchesYear &&
                visibilityByCollapse
            ) {
                totalMatchingCount++;
                if (visibleCount < itemsToShow) {
                    htmlEvent.classList.remove("hidden-by-filter");
                    visibleCount++;
                } else {
                    htmlEvent.classList.add("hidden-by-filter");
                }
            } else {
                htmlEvent.classList.add("hidden-by-filter");
            }
        });

        document.querySelectorAll(".month-section").forEach((section) => {
            const htmlSection = section as HTMLElement;
            const eventsInSection = Array.from(
                htmlSection.querySelectorAll(".timeline-event"),
            );
            const hasVisibleEvent = eventsInSection.some(
                (e) => !(e as HTMLElement).classList.contains("hidden-by-filter")
            );

            if (hasVisibleEvent) {
                htmlSection.style.display = "block";
            } else {
                htmlSection.style.display = "none";
            }
        });

        if (showMoreButton) {
            if (totalMatchingCount > itemsToShow) {
                showMoreButton.classList.remove("hidden");
                showMoreButton.textContent = `Show more activity (${totalMatchingCount - itemsToShow} remaining)`;
            } else {
                showMoreButton.classList.add("hidden");
            }
        }

        if (noResults) {
            if (totalMatchingCount === 0) noResults.classList.remove("hidden");
            else noResults.classList.add("hidden");
        }
    }

    if (showMoreButton) {
        showMoreButton.addEventListener("click", () => {
            itemsToShow += 10;
            updateDisplay();
        });
    }

    const yearButtons = document.querySelectorAll(".year-btn");
    const monthButtons = document.querySelectorAll(".month-btn");

    function selectYear(year: string, button: HTMLElement, isManualClick: boolean = false) {
        const yearItem = button.closest(".year-item") as HTMLElement;
        const monthSubmenu = yearItem?.querySelector(
            ".month-submenu",
        ) as HTMLElement;

        itemsToShow = 10;
        document.documentElement.setAttribute('data-selected-year', year);

        if (currentYear === year) {
            if (monthSubmenu && isManualClick) {
                monthSubmenu.classList.toggle("hidden");
            }
        } else {
            yearButtons.forEach((btn) => {
                const item = btn.closest(".year-item");
                const submenu = item?.querySelector(".month-submenu");
                if (submenu) submenu.classList.add("hidden");
            });

            currentYear = year;

            if (window.updateHeatmapYear) {
                window.updateHeatmapYear(parseInt(year));
            }
        }
        updateDisplay();
    }

    yearButtons.forEach((button) => {
        button.addEventListener("click", (event) => {
            const year = (button as HTMLElement).dataset.year || "all";
            localStorage.setItem('selectedYear', year);
            selectYear(year, button as HTMLElement, event.isTrusted);
        });
    });

    monthButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const monthKey = (button as HTMLElement).dataset.month || "";
            const year = (button as HTMLElement).dataset.year || "all";

            itemsToShow = 500;

            if (currentYear !== year) {
                localStorage.setItem('selectedYear', year);
                const yearBtn = document.querySelector(
                    `.year-btn[data-year="${year}"]`,
                ) as HTMLElement;
                if (yearBtn) selectYear(year, yearBtn, false);
            }

            updateDisplay();

            setTimeout(() => {
                const monthSection = document.querySelector(
                    `.month-section[data-month="${monthKey}"]`,
                );
                if (monthSection) {
                    monthSection.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                    });
                }
            }, 10);
        });
    });

    window.addEventListener("dateFilterChange", (e: any) => {
        currentDateFilter = e.detail.date;
        itemsToShow = 10;
        updateDisplay();
    });

    window.addEventListener("updateDisplayNeeded", () => {
        updateDisplay();
    });

    const initYearSelection = () => {
        const savedYear = localStorage.getItem('selectedYear');
        const currentYearStr = new Date().getFullYear().toString();
        const yearToSelect = savedYear || currentYearStr;

        let yearBtn = document.querySelector(
            `.year-btn[data-year="${yearToSelect}"]`,
        ) as HTMLElement;

        if (!yearBtn && savedYear) {
            yearBtn = document.querySelector(
                `.year-btn[data-year="${currentYearStr}"]`,
            ) as HTMLElement;
        }

        if (yearBtn) {
            selectYear(yearBtn.dataset.year || currentYearStr, yearBtn, false);
        } else {
            const allYearBtns = document.querySelectorAll(".year-btn");
            if (allYearBtns.length > 0) {
                const firstBtn = allYearBtns[0] as HTMLElement;
                selectYear(firstBtn.dataset.year || currentYearStr, firstBtn, false);
            }
        }

        document.documentElement.classList.add('js-initialized');
    };

    initYearSelection();
</script>
