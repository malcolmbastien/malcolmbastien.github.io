---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "../layouts/Layout.astro";
import ActivityHeatmap from "../components/Profile/ActivityHeatmap.astro";
import ProfileHeader from "../components/Profile/ProfileHeader.astro";
import YearNavigation from "../components/YearNavigation.astro";
import PostTimeline from "../components/PostTimeline.astro";
import SiteFooter from "../components/SiteFooter.astro";
import { getFileDates } from "../lib/git-history";

const allPosts = await getCollection("posts");

// Fetch git dates for all posts to create timeline events
const postsWithDates = await Promise.all(
    allPosts.map(async (post) => {
        const filePath = `src/content/posts/${post.id}`;
        const { created, updated } = await getFileDates(filePath);
        return {
            ...post,
            displayDate: post.data.publishedDate || created || new Date(),
            updatedDate: updated || created || new Date(),
        };
    }),
);

// Create timeline events
const events: any[] = [];
postsWithDates.forEach((post) => {
    // Add creation event
    events.push({
        type: "created",
        post,
        date: post.displayDate,
        title: post.data.title,
    });

    // Add update event if updated significantly later
    if (
        post.updatedDate.getTime() >
        post.displayDate.getTime() + 1000 * 60 * 60
    ) {
        // More than 1 hour
        events.push({
            type: "updated",
            post,
            date: post.updatedDate,
            title: post.data.title,
        });
    }
});

// Aggregate events: group multiple updates to same post within short time
const aggregatedEvents: any[] = [];
const eventGroups = new Map();

events.forEach((event) => {
    const key = `${event.post.slug}-${event.type}`;
    if (!eventGroups.has(key)) {
        eventGroups.set(key, []);
    }
    eventGroups.get(key).push(event);
});

eventGroups.forEach((group) => {
    if (group.length === 1) {
        aggregatedEvents.push(group[0]);
    } else {
        // Multiple events, aggregate them
        const firstEvent = group[0];
        const lastEvent = group[group.length - 1];
        aggregatedEvents.push({
            ...firstEvent,
            count: group.length,
            date: lastEvent.date, // Use the most recent date
        });
    }
});

// Sort events by date descending
const sortedEvents = aggregatedEvents.sort(
    (a, b) => b.date.valueOf() - a.date.valueOf(),
);

// Generate all months from earliest event to now
const earliestDate = sortedEvents.length > 0
    ? sortedEvents[sortedEvents.length - 1]?.date || new Date()
    : new Date();
const latestDate = sortedEvents.length > 0
    ? sortedEvents[0]?.date || new Date()
    : new Date();

const allMonths: Array<{
    key: string;
    date: Date;
    hasActivity: boolean;
}> = [];

const currentDate = new Date();
currentDate.setDate(1); // Start from first day of current month
currentDate.setHours(0, 0, 0, 0);

const endDate = new Date(earliestDate);
endDate.setDate(1);
endDate.setHours(0, 0, 0, 0);

// Group events by month for quick lookup
const eventsByMonthKey = new Map<string, any[]>();
sortedEvents.forEach((event) => {
    const monthKey = event.date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    if (!eventsByMonthKey.has(monthKey)) {
        eventsByMonthKey.set(monthKey, []);
    }
    eventsByMonthKey.get(monthKey)?.push(event);
});

// Generate all months from current to earliest
while (currentDate >= endDate) {
    const monthKey = currentDate.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    allMonths.push({
        key: monthKey,
        date: new Date(currentDate),
        hasActivity: eventsByMonthKey.has(monthKey),
    });

    // Move to previous month
    currentDate.setMonth(currentDate.getMonth() - 1);
}

// Collect years data for sidebar
const yearsData = new Map();
sortedEvents.forEach((event) => {
    const year = event.date.getFullYear();
    const month = event.date.getMonth();

    if (!yearsData.has(year)) {
        yearsData.set(year, { count: 0, months: new Set() });
    }
    yearsData.get(year).count++;
    yearsData.get(year).months.add(month);
});

// Convert to array and sort by year descending
const yearsArray = Array.from(yearsData.entries());
yearsArray.sort((a, b) => b[0] - a[0]);
const sortedYears = yearsArray.map(([year, data]) => ({
    year: year as number,
    count: data.count as number,
    months: (Array.from(data.months) as number[]).sort((a, b) => b - a), // months descending within year
}));

// Default to current year for heatmap
const currentYear = new Date().getFullYear();
---

<Layout
    title="Sprout - A Digital Garden"
    description="A digital garden of thoughts and ideas. Explore seeds, sprouts, and trees of knowledge in this ever-growing collection of writings."
    type="website"
>
    <main class="max-w-7xl mx-auto p-4 md:p-8">
        <ProfileHeader />

        <div class="flex gap-8">
            <!-- Left Column: Activity Heatmap and Timeline -->
            <div class="flex-1 space-y-6">
                <ActivityHeatmap year={currentYear} events={sortedEvents as any} />
                <PostTimeline sortedEvents={sortedEvents} allMonths={allMonths} eventsByMonthKey={eventsByMonthKey} />
            </div>

            <!-- Right Column: Search, Filters, and Years Navigation -->
            <div class="w-64 shrink-0 sticky top-8 h-fit">
                <!-- Search Garden -->
                <div
                    class="bg-white dark:bg-[#121812] border border-slate-200 dark:border-slate-800 rounded-xl p-4 mb-6"
                >
                    <div class="relative group w-full">
                        <input
                            type="text"
                            id="search-input"
                            placeholder="Search garden..."
                            class="w-full pl-10 pr-4 py-2 bg-white dark:bg-[#121812] border border-slate-200 dark:border-slate-800 rounded-full text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500/20 focus:border-emerald-500 transition-all dark:text-slate-200"
                        />
                        <svg
                            class="absolute left-3 top-2.5 h-4 w-4 text-slate-400 group-focus-within:text-emerald-500 transition-colors"
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                            ></path>
                        </svg>
                    </div>
                </div>

                <!-- Tag/Event Type Filters -->
                <div
                    class="bg-white dark:bg-[#121812] border border-slate-200 dark:border-slate-800 rounded-xl p-4 mb-6"
                >
                    <div class="flex flex-wrap gap-2" id="event-type-filters">
                        <button
                            class="tag-btn px-3 py-1.5 rounded-full text-xs font-medium"
                            data-event-type="created">üå± Created</button
                        >
                        <button
                            class="tag-btn px-3 py-1.5 rounded-full text-xs font-medium"
                            data-event-type="updated">‚úèÔ∏è Updated</button
                        >
                    </div>
                </div>

                <!-- Years Navigation -->
                <YearNavigation sortedYears={sortedYears as any} />
            </div>
        </div>
        <SiteFooter />
    </main>
</Layout>

<script>
declare global {
    interface Window {
        updateHeatmapYear?: (year: number) => void;
    }
}

    const buttons = document.querySelectorAll("[data-status]");
    const tagButtons = document.querySelectorAll("[data-tag]");
    const eventTypeButtons = document.querySelectorAll("[data-event-type]");
    const searchInput = document.getElementById(
        "search-input",
    ) as HTMLInputElement;
    const timelineEvents = document.querySelectorAll(".timeline-event");
    const noResults = document.getElementById("no-results");

    let currentFilter = "all";
    let currentTag = "";
    let currentEventType = "all";
    let currentYear = "all";
    let searchQuery = "";
    let currentDateFilter: string | null = null;
 
    function updateDisplay() {
        let visibleCount = 0;

        // Re-query to include dynamically added events
        const allTimelineEvents = document.querySelectorAll(".timeline-event");

        allTimelineEvents.forEach((event) => {
            const htmlEvent = event as HTMLElement;
            const status = htmlEvent.dataset.status;
            const title = htmlEvent.dataset.title || "";
            const summary = htmlEvent.dataset.summary || "";
            const tags = htmlEvent.dataset.tags || "";
            const createdDate = htmlEvent.dataset.created || "";
            const updatedDate = htmlEvent.dataset.updated || "";
            const eventType = htmlEvent.dataset.eventType;

            const matchesFilter =
                currentFilter === "all" || status === currentFilter;
            const matchesTag = currentTag === "" || tags.includes(currentTag);
            const matchesEventType =
                currentEventType === "all" || eventType === currentEventType;
            const eventYear = new Date(createdDate).getFullYear().toString();
            const matchesYear =
                currentYear === "all" || eventYear === currentYear;
            const matchesSearch =
                title.includes(searchQuery) ||
                summary.includes(searchQuery) ||
                tags.includes(searchQuery);
            const matchesDate =
                currentDateFilter === null ||
                createdDate.startsWith(currentDateFilter) ||
                updatedDate.startsWith(currentDateFilter);

            if (
                matchesFilter &&
                matchesTag &&
                matchesEventType &&
                matchesYear &&
                matchesSearch &&
                matchesDate
            ) {
                htmlEvent.style.display = "flex";
                visibleCount++;
            } else {
                htmlEvent.style.display = "none";
            }
        });

        if (noResults) {
            if (visibleCount === 0) noResults.classList.remove("hidden");
            else noResults.classList.add("hidden");
        }
    }

    buttons.forEach((button) => {
        button.addEventListener("click", () => {
            const status = (button as HTMLElement).dataset.status || "all";
            if (currentFilter === status) {
                // Clicking active button deactivates it
                button.classList.remove("active");
                currentFilter = "all";
            } else {
                buttons.forEach((btn) => btn.classList.remove("active"));
                button.classList.add("active");
                currentFilter = status;
            }
            updateDisplay();
        });
    });

    tagButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const tag = (button as HTMLElement).dataset.tag || "";
            if (currentTag === tag) {
                // Clicking active tag deactivates it
                button.classList.remove("active");
                currentTag = "";
            } else {
                tagButtons.forEach((btn) => btn.classList.remove("active"));
                button.classList.add("active");
                currentTag = tag;
            }
            updateDisplay();
        });
    });

    eventTypeButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const eventType =
                (button as HTMLElement).dataset.eventType || "all";
            if (currentEventType === eventType) {
                // Clicking active button deactivates it
                button.classList.remove("active");
                currentEventType = "all";
            } else {
                eventTypeButtons.forEach((btn) =>
                    btn.classList.remove("active"),
                );
                button.classList.add("active");
                currentEventType = eventType;
            }
            updateDisplay();
        });
    });

    // Year navigation
    const yearButtons = document.querySelectorAll(".year-btn");
    const monthButtons = document.querySelectorAll(".month-btn");

    yearButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const year = (button as HTMLElement).dataset.year || "all";
            const yearItem = button.closest(".year-item") as HTMLElement;
            const monthSubmenu = yearItem?.querySelector(
                ".month-submenu",
            ) as HTMLElement;

            if (currentYear === year) {
                // Clicking active year toggles submenu
                if (monthSubmenu) {
                    monthSubmenu.classList.toggle("hidden");
                }
            } else {
                // Select new year
                yearButtons.forEach((btn) => {
                    btn.classList.remove("active");
                    const item = btn.closest(".year-item");
                    const submenu = item?.querySelector(".month-submenu");
                    if (submenu) submenu.classList.add("hidden");
                });
                button.classList.add("active");
                currentYear = year;

                // Show submenu for selected year
                if (monthSubmenu) {
                    monthSubmenu.classList.remove("hidden");
                }

                // Update activity heatmap to show selected year
                if (window.updateHeatmapYear) {
                    window.updateHeatmapYear(parseInt(year));
                }
            }
            updateDisplay();
        });
    });

    monthButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const monthData = (button as HTMLElement).dataset.month || "";
            const [year, month] = monthData.split("-");

        });
    });

    searchInput?.addEventListener("input", (e) => {
        searchQuery = (e.target as HTMLInputElement).value.toLowerCase();
        updateDisplay();
    });

    // Listen for date filter changes from activity heatmap
    window.addEventListener("dateFilterChange", (e: any) => {
        currentDateFilter = e.detail.date;
        updateDisplay();
    });

    // Listen for display updates when new months are revealed
    window.addEventListener("updateDisplayNeeded", () => {
        updateDisplay();
    });

    // Prevent any interference with timeline event clicks
    document.querySelectorAll(".timeline-event").forEach((event) => {
        event.addEventListener(
            "click",
            (e) => {
                // Ensure no event bubbling that could trigger filtering
                e.stopPropagation();
            },
            true,
        ); // Capture phase

        // Prevent focus/blur events that might trigger updates
        event.addEventListener("focus", (e) => e.stopPropagation(), true);
        event.addEventListener("blur", (e) => e.stopPropagation(), true);
    });

    // Check URL params for initial tag filter
    const urlParams = new URLSearchParams(window.location.search);
    const tagParam = urlParams.get("tag");
    if (tagParam) {
        currentTag = tagParam;
        // Find and activate tag button
        const targetTagBtn = Array.from(tagButtons).find(
            (btn) => (btn as HTMLElement).dataset.tag === tagParam,
        );
        if (targetTagBtn) {
            targetTagBtn.classList.add("active");
            tagButtons.forEach((btn) => {
                if (btn !== targetTagBtn) btn.classList.remove("active");
            });
        }
        // Update display to filter by tag
        updateDisplay();
    }
</script>
