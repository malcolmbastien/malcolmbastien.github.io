---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "../layouts/Layout.astro";
import ActivityHeatmap from "../components/Profile/ActivityHeatmap.astro";
import Header from "../components/Profile/Header.astro";
import YearNavigation from "../components/YearNavigation.astro";
import NoteTimeline from "../components/NoteTimeline.astro";
import SiteFooter from "../components/SiteFooter.astro";
import GardenStats from "../components/Profile/GardenStats.astro";
import SocialLinks from "../components/Profile/SocialLinks.astro";
import TopicFocus from "../components/Profile/TopicFocus.astro";
import { getStageColors } from "../lib/theme";
import { getBatchFileDates, type FileDates } from "../lib/git-history";
import AboutAuthor from "../components/AboutAuthor.astro";

const allNotes = await getCollection("notes");
const batchDates = (await getBatchFileDates()) as Map<string, FileDates>;
const stageColors = getStageColors();

// Fetch git dates for all notes to create timeline events
const notesWithDates = allNotes.map((note) => {
    const id = note.id;
    const dates = batchDates.get(`src/content/notes/${id}`) ||
                  batchDates.get(`src/content/notes/${id}.md`) ||
                  batchDates.get(`src/content/notes/${id}.mdx`);

    const created = dates?.created;
    const allGitDates = dates?.allDates || new Set<string>();

    const displayDate = note.data.publishedDate || created;

    return {
        ...note,
        displayDate,
        allGitDates,
    };
}).filter((note): note is typeof note & { displayDate: Date } => !!note.displayDate); // Only show notes that have a valid date from frontmatter or git

// Create timeline events
const events: any[] = [];
notesWithDates.forEach((note) => {
    const displayDate = note.displayDate as Date;
    const displayDateStr = displayDate.toISOString().split("T")[0];

    // Add creation event
    events.push({
        type: "created",
        note,
        date: displayDate,
        title: note.data.title,
    });

    // Add update events for all other unique git dates
    note.allGitDates.forEach((dateStr: string) => {
        // Only add as update if it's a different day than creation
        if (dateStr !== displayDateStr) {
            // We use 12:00 PM for these historical updates to ensure they sort reasonably
            // or we could try to find the actual time, but dateStr is just the day
            const updateDate = new Date(dateStr + "T12:00:00");
            events.push({
                type: "updated",
                note,
                date: updateDate,
                title: note.data.title,
            });
        }
    });
});

// Aggregate events: group multiple updates to same note within short time
const aggregatedEvents: any[] = [];
const eventGroups = new Map();

events.forEach((event) => {
    // Group by slug, type, AND date (day) to ensure at most one event per note per day per type
    const dateStr = (event.date as Date).toISOString().split("T")[0];
    const key = `${event.note.slug}-${event.type}-${dateStr}`;
    if (!eventGroups.has(key)) {
        eventGroups.set(key, []);
    }
    eventGroups.get(key).push(event);
});

eventGroups.forEach((group) => {
    if (group.length === 1) {
        aggregatedEvents.push(group[0]);
    } else {
        // Multiple events, aggregate them
        const firstEvent = group[0];
        const lastEvent = group[group.length - 1];
        aggregatedEvents.push({
            ...firstEvent,
            count: group.length,
            date: lastEvent.date, // Use the most recent date
        });
    }
});

// Sort events by date descending
const sortedEvents = aggregatedEvents.sort(
    (a, b) => b.date.valueOf() - a.date.valueOf(),
);

// Identify which events to collapse in the timeline (show only one update per note per month)
const creationsInMonth = new Set<string>();
sortedEvents.forEach((e) => {
    if (e.type === "created") {
        const monthKey = e.date.toLocaleDateString("en-US", {
            year: "numeric",
            month: "long",
        });
        creationsInMonth.add(`${e.note.slug}-${monthKey}`);
    }
});

const seenUpdateInMonth = new Set<string>();
sortedEvents.forEach((event) => {
    const monthKey = event.date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    const noteKey = `${event.note.slug}-${monthKey}`;

    if (event.type === "created") {
        event.isCollapsed = false;
    } else {
        // It's an update - collapse if there's a creation or a later update in the same month
        if (creationsInMonth.has(noteKey) || seenUpdateInMonth.has(noteKey)) {
            event.isCollapsed = true;
        } else {
            event.isCollapsed = false;
            seenUpdateInMonth.add(noteKey);
        }
    }
});

// Generate all months from earliest event to now
const earliestDate =
    sortedEvents.length > 0
        ? sortedEvents[sortedEvents.length - 1]?.date || new Date()
        : new Date();
const latestDate =
    sortedEvents.length > 0 ? sortedEvents[0]?.date || new Date() : new Date();

const allMonths: Array<{
    key: string;
    date: Date;
    hasActivity: boolean;
}> = [];

const currentDate = new Date();
currentDate.setDate(1); // Start from first day of current month
currentDate.setHours(0, 0, 0, 0);

const endDate = new Date(earliestDate);
endDate.setDate(1);
endDate.setHours(0, 0, 0, 0);

// Group events by month for quick lookup
const eventsByMonthKey = new Map<string, any[]>();
sortedEvents.forEach((event) => {
    const monthKey = event.date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    if (!eventsByMonthKey.has(monthKey)) {
        eventsByMonthKey.set(monthKey, []);
    }
    eventsByMonthKey.get(monthKey)?.push(event);
});

// Generate all months from current to earliest
while (currentDate >= endDate) {
    const monthKey = currentDate.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    allMonths.push({
        key: monthKey,
        date: new Date(currentDate),
        hasActivity: eventsByMonthKey.has(monthKey),
    });

    // Move to previous month
    currentDate.setMonth(currentDate.getMonth() - 1);
}

// Collect years data for sidebar
const yearsData = new Map();
sortedEvents.forEach((event) => {
    const year = event.date.getFullYear();
    const month = event.date.getMonth();

    if (!yearsData.has(year)) {
        yearsData.set(year, { count: 0, months: new Set(), uniqueNotes: new Set() });
    }
    yearsData.get(year).count++; // Total activity for dots
    yearsData.get(year).months.add(month);
    yearsData.get(year).uniqueNotes.add(event.note.id); // Unique notes for the count label
});

// Convert to array and sort by year descending
const yearsArray = Array.from(yearsData.entries());
yearsArray.sort((a, b) => b[0] - a[0]);
const sortedYears = yearsArray.map(([year, data]) => ({
    year: year as number,
    count: data.uniqueNotes.size, // Number of unique notes touched
    activityCount: data.count as number, // Total activity volume
    months: (Array.from(data.months) as number[]).sort((a, b) => b - a), // months descending within year
}));

// Identify pinned notes
const pinnedNotes = allNotes.filter((note) => (note.data as any).pinned === true);

// Get latest 3 created notes (that aren't pinned)
const latestCreations = notesWithDates
    .filter(p => !!p.displayDate && !pinnedNotes.some(pinned => pinned.id === p.id))
    .sort((a, b) => b.displayDate!.valueOf() - a.displayDate!.valueOf())
    .slice(0, 3);

// Sort notes for stats
const sortedNotes = notesWithDates.sort(
    (a, b) => b.displayDate.valueOf() - a.displayDate.valueOf(),
);

// Compute note counts by stage
const publishedNotes = allNotes.filter((note) => note.data);
const counts = {
    all: publishedNotes.length,
    seed: publishedNotes.filter((n: any) => n.data.stage === "seed").length,
    sprout: publishedNotes.filter((n: any) => n.data.stage === "sprout")
        .length,
    evergreen: publishedNotes.filter((n: any) => n.data.stage === "evergreen").length,
};

// Default to current year for heatmap
const currentYearValue = new Date().getFullYear();
---



<Layout
    title="Sprout - A Digital Garden"
    description="A digital garden of thoughts and ideas. Explore seeds, sprouts, and evergreens of knowledge in this ever-growing collection of writings."
    type="website"
>
    <style slot="head" is:inline set:html={
        sortedYears.map(y => `
        /* Instant CSS-driven filtering */
        html[data-selected-year="${y.year}"] .timeline-event:not([data-event-year="${y.year}"]),
        html[data-selected-year="${y.year}"] .month-section:not([data-year="${y.year}"]) {
            display: none !important;
        }

        /* Initial batching protection (before JS takes over) */
        html:not(.js-initialized)[data-selected-year="${y.year}"] .timeline-event[data-event-year="${y.year}"][data-is-initial-batch="false"] {
            display: none !important;
        }
        html:not(.js-initialized)[data-selected-year="${y.year}"] .month-section[data-year="${y.year}"]:not(:has(.timeline-event[data-event-year="${y.year}"][data-is-initial-batch="true"])) {
            display: none !important;
        }

        /* Instant Sidebar Highlighting v1.1 */
        html[data-selected-year="${y.year}"] .year-btn[data-year="${y.year}"] {
            color: #0055FF !important;
            border-left-color: #0055FF !important;
            padding-left: 0.75rem !important;
        }
        html[data-selected-year="${y.year}"] .year-btn[data-year="${y.year}"] span {
            color: #0055FF !important;
        }
        html[data-selected-year="${y.year}"] .year-item:has(.year-btn[data-year="${y.year}"]) .month-submenu {
            display: block !important;
        }
        `).join('')
    } />
    <script slot="head" is:inline>
        // Set the selected year as early as possible in the HEAD to allow for CSS-driven filtering
        (function() {
            const savedYear = localStorage.getItem('selectedYear');
            const currentYear = new Date().getFullYear().toString();
            document.documentElement.setAttribute('data-selected-year', savedYear || currentYear);
        })();
    </script>
    <main class="max-w-(--breakpoint-xl) mx-auto p-4 md:p-8" data-pagefind-ignore>
        <Header currentPath={Astro.url.pathname}>
            <ActivityHeatmap
                slot="heatmap"
                year={currentYearValue}
                events={sortedEvents as any}
            />
        </Header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-4">
            <!-- Year Rail  (Col 1) -->
            <div class="lg:col-span-1 space-y-8">
                <div class="lg:sticky lg:top-24">
                    <YearNavigation sortedYears={sortedYears as any} />
                </div>
            </div>

            <!--  Activity Heatmap + Primary Stream (Col 2-8) -->
            <div class="lg:col-span-7 space-y-12">
                {
                    pinnedNotes.length > 0 && (
                        <div class="space-y-6">
                            <div class="flex items-center gap-4">
                                <div class="w-2 h-2 bg-blueprint-blue rounded-full"></div>
                                <h3 class="text-xs font-sans font-bold  text-terminal-dark dark:text-white tracking-widest uppercase">
                                    Pinned Notes
                                </h3>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                {pinnedNotes.map((note) => (
                                     <a
                                        href={`/notes/${note.id.replace('.md', '')}`}
                                        class="card-blueprint pinned-note group block p-6 bg-white dark:bg-slate-800 hover:-translate-y-0.5 hover:shadow-[0_4px_20px_-5px_rgba(0,85,255,0.1)] transition-all"
                                     >
                                        <div class="flex justify-between items-start mb-4">
                                             <span class={`text-sm font-bold dark:text-white ${
                                                  note.data.stage === 'seed' ? 'text-andon-amber' :
                                                  note.data.stage === 'sprout' ? 'text-teal-600' :
                                                  note.data.stage === 'evergreen' ? 'text-andon-emerald' : 'text-blueprint-blue'
                                             }`}>
                                                 {note.data.stage.charAt(0).toUpperCase() + note.data.stage.slice(1)}
                                             </span>
                                            <span class="text-sm text-slate-500 dark:text-slate-400">Pinned</span>
                                        </div>
                                        <h3 class="text-xl font-sans font-bold text-terminal-dark dark:text-white mb-2 leading-tight group-hover:text-blueprint-blue transition-colors">
                                            {note.data.title}
                                        </h3>
                                        {note.data.summary && (
                                            <p class="text-base text-slate-600 dark:text-slate-400 line-clamp-2 leading-relaxed">
                                                {note.data.summary}
                                            </p>
                                        )}
                                    </a>
                                ))}
                            </div>
                        </div>
                    )
                }

                <NoteTimeline
                    sortedEvents={sortedEvents}
                    allMonths={allMonths}
                    eventsByMonthKey={eventsByMonthKey}
                    initialYear={currentYearValue.toString()}
                />
            </div>

            <!-- Contextual Side (Col 9-12) -->
            <div class="lg:col-span-4 space-y-8">
                 <!-- Latest Creations -->
                 <div class="card-blueprint p-6 bg-white dark:bg-slate-800">
                     <h3 class="text-xs font-sans font-bold text-slate-500 dark:text-slate-400 mb-6 tracking-widest uppercase">Latest Creations</h3>
                     <div class="space-y-4">
                          {latestCreations.map((note) => (
                              <a href={`/notes/${note.id.replace('.md', '')}`} class="block group">
                                 <div class="flex justify-between items-start mb-2">
                                     <span class={`text-sm font-bold ${
                                          note.data.stage === 'evergreen' ? 'text-andon-emerald' :
                                          note.data.stage === 'seed' ? 'text-andon-amber' :
                                          'text-teal-600'
                                     }`}>
                                         {note.data.stage.toUpperCase()}
                                     </span>
                                     <time class="text-xs text-slate-500 dark:text-slate-400">
                                         {note.displayDate!.toLocaleDateString("en-US", { month: 'short', day: 'numeric' })}
                                     </time>
                                 </div>
                                 <h4 class="text-base font-bold text-terminal-dark dark:text-white group-hover:text-blueprint-blue transition-colors">
                                     {note.data.title}
                                 </h4>
                             </a>
                         ))}
                     </div>
                 </div>

                   <AboutAuthor />

                 <!-- Garden Stats -->
                 <div class="card-blueprint p-6 bg-white">
                     <GardenStats
                         counts={counts}
                         sortedNotes={sortedNotes}
                         allNotes={allNotes}
                         progressColors={stageColors}
                     />
                 </div>

                <!-- Search Box v1.1 -->
                <div class="card-blueprint p-6 bg-white dark:bg-slate-800">
                    <h3 class="text-xs font-sans font-bold text-slate-500 dark:text-slate-400 mb-6 tracking-widest uppercase">Search</h3>
                    <a
                        href="/search"
                        class="flex items-center gap-4 w-full px-5 py-4 bg-tooling-gray dark:bg-slate-900 border border-slate-200 dark:border-slate-700 text-slate-500 dark:text-slate-400 hover:border-blueprint-blue hover:text-blueprint-blue dark:hover:text-white transition-all group"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-4 w-4"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                            ></path>
                        </svg>
                        <span class="text-sm font-bold text-slate-500 dark:text-slate-400 group-hover:text-terminal-dark dark:group-hover:text-white transition-colors">Search notes...</span>
                    </a>
                </div>

                <TopicFocus />

                <div class="card-blueprint p-6 bg-white dark:bg-slate-800">
                    <h3 class="text-xs font-sans font-bold text-slate-500 dark:text-slate-400 mb-6 tracking-widest uppercase">Social Links</h3>
                    <SocialLinks class="border-none p-0 bg-transparent shadow-none!" />
                </div>
            </div>
        </div>
        <SiteFooter />
    </main>
</Layout>

<style is:global>
    @reference "../styles/global.css";

    /* Styling for the scrollable sidebar */
    .custom-sidebar-scroll {
        scrollbar-width: thin;
        scrollbar-color: #f1f5f9 transparent;
    }
    .dark .custom-sidebar-scroll {
        scrollbar-color: #1e293b transparent;
    }
    .custom-sidebar-scroll::-webkit-scrollbar {
        width: 3px;
    }
    .custom-sidebar-scroll::-webkit-scrollbar-track {
        background: transparent;
    }
    .custom-sidebar-scroll::-webkit-scrollbar-thumb {
        @apply bg-slate-100 dark:bg-slate-800;
    }

    /* CSS-driven filtering for instant load */
    .timeline-event.hidden-by-filter {
        display: none !important;
    }
</style>

<script>
    declare global {
        interface Window {
            updateHeatmapYear?: (year: number) => void;
        }
    }

    const buttons = document.querySelectorAll("[data-stage]");
    const topicButtons = document.querySelectorAll("[data-topic]");
    const eventTypeButtons = document.querySelectorAll("[data-event-type]");
    const timelineEvents = document.querySelectorAll("#timeline .timeline-event");
    const noResults = document.getElementById("no-results");

    // Prevent browser from automatically restoring scroll position which can cause jumps
    // when we dynamically filter content on load.
    if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }

    let currentFilter = "all";
    let currentTopic = "";
    let currentEventType = "all";
    let currentYear = document.documentElement.getAttribute('data-selected-year') || new Date().getFullYear().toString();
    let currentDateFilter: string | null = null;
    let itemsToShow = 10;

    const showMoreButton = document.getElementById("show-more-activity");

    function updateDisplay() {
        let totalMatchingCount = 0;
        let visibleCount = 0;

        // Re-query to include dynamically added events
        const allTimelineEvents = document.querySelectorAll("#timeline .timeline-event");

        allTimelineEvents.forEach((event) => {
            const htmlEvent = event as HTMLElement;
            const stage = htmlEvent.dataset.stage;
            const eventYear = htmlEvent.dataset.eventYear || "";
            const eventType = htmlEvent.dataset.eventType;

            const matchesFilter =
                currentFilter === "all" || stage === currentFilter;
            const matchesTopic = currentTopic === "" || (htmlEvent.dataset.topics || "").includes(currentTopic);
            const matchesEventType =
                currentEventType === "all" || eventType === currentEventType;

            // Year matching is now handled by CSS for the initial paint,
            // but we keep this check for the "totalMatchingCount" and "Show More" logic.
            const matchesYear =
                currentYear === "all" || eventYear === currentYear;

            const isCollapsed = htmlEvent.dataset.isCollapsed === "true";

            // If filtering by a specific date from the heatmap
            const eventDate = htmlEvent.dataset.created || "";
            const matchesDate =
                currentDateFilter === null || eventDate === currentDateFilter;

            // Logic:
            // 1. If we have a specific date filter, show the event if it matches the date, even if collapsed
            // 2. If no date filter, hide collapsed events
            const visibilityByCollapse = currentDateFilter !== null ? matchesDate : !isCollapsed;

            if (
                matchesFilter &&
                matchesTopic &&
                matchesEventType &&
                matchesYear &&
                visibilityByCollapse
            ) {
                totalMatchingCount++;
                if (visibleCount < itemsToShow) {
                    htmlEvent.classList.remove("hidden-by-filter");
                    visibleCount++;
                } else {
                    htmlEvent.classList.add("hidden-by-filter");
                }
            } else {
                htmlEvent.classList.add("hidden-by-filter");
            }
        });

        // Show/hide month sections based on their visible events
        document.querySelectorAll(".month-section").forEach((section) => {
            const htmlSection = section as HTMLElement;
            const eventsInSection = Array.from(
                htmlSection.querySelectorAll(".timeline-event"),
            );
            const hasVisibleEvent = eventsInSection.some(
                (e) => !(e as HTMLElement).classList.contains("hidden-by-filter")
            );

            if (hasVisibleEvent) {
                htmlSection.style.display = "block";
            } else {
                htmlSection.style.display = "none";
            }
        });

        // Update "Show more" button
        if (showMoreButton) {
            if (totalMatchingCount > itemsToShow) {
                showMoreButton.classList.remove("hidden");
                showMoreButton.textContent = `Show more activity (${totalMatchingCount - itemsToShow} remaining)`;
            } else {
                showMoreButton.classList.add("hidden");
            }
        }

        if (noResults) {
            if (totalMatchingCount === 0) noResults.classList.remove("hidden");
            else noResults.classList.add("hidden");
        }
    }

    if (showMoreButton) {
        showMoreButton.addEventListener("click", () => {
            itemsToShow += 10;
            updateDisplay();
        });
    }

    eventTypeButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const eventType =
                (button as HTMLElement).dataset.eventType || "all";
            itemsToShow = 10;
            if (currentEventType === eventType) {
                button.classList.remove("active");
                currentEventType = "all";
            } else {
                eventTypeButtons.forEach((btn) =>
                    btn.classList.remove("active"),
                );
                button.classList.add("active");
                currentEventType = eventType;
            }
            updateDisplay();
        });
    });

    // Year and Month navigation
    const yearButtons = document.querySelectorAll(".year-btn");
    const monthButtons = document.querySelectorAll(".month-btn");

    function selectYear(year: string, button: HTMLElement, isManualClick: boolean = false) {
        const yearItem = button.closest(".year-item") as HTMLElement;
        const monthSubmenu = yearItem?.querySelector(
            ".month-submenu",
        ) as HTMLElement;

        itemsToShow = 10;

        // Update the data attribute for CSS filtering (instant highlighting/hiding)
        document.documentElement.setAttribute('data-selected-year', year);

        if (currentYear === year) {
            if (monthSubmenu && isManualClick) {
                // If it's a manual click on the same year, we toggle the submenu
                // But we check if it was previously forced visible by CSS or JS
                monthSubmenu.classList.toggle("hidden");
            }
        } else {
            // Note: .active class removal is still done for manual clicks to clean up
            // any JS-applied states, though CSS attribute handles most styling now.
            yearButtons.forEach((btn) => {
                btn.classList.remove("active");
                const item = btn.closest(".year-item");
                const submenu = item?.querySelector(".month-submenu");
                if (submenu) submenu.classList.add("hidden");
            });

            // We set the variable but let the [data-selected-year] handle the UI
            currentYear = year;

            if (window.updateHeatmapYear) {
                window.updateHeatmapYear(parseInt(year));
            }
        }
        updateDisplay();
    }

    yearButtons.forEach((button) => {
        button.addEventListener("click", (event) => {
            const year = (button as HTMLElement).dataset.year || "all";

            // Preserve the selected year in local storage
            localStorage.setItem('selectedYear', year);

            selectYear(year, button as HTMLElement, event.isTrusted);
        });
    });

    monthButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const monthKey = (button as HTMLElement).dataset.month || "";
            const year = (button as HTMLElement).dataset.year || "all";

            itemsToShow = 500; // Increase limit to ensure month content is visible

            if (currentYear !== year) {
                localStorage.setItem('selectedYear', year);
                const yearBtn = document.querySelector(
                    `.year-btn[data-year="${year}"]`,
                ) as HTMLElement;
                if (yearBtn) selectYear(year, yearBtn, false);
            }

            updateDisplay();

            // Scroll to the selected month section
            setTimeout(() => {
                const monthSection = document.querySelector(
                    `.month-section[data-month="${monthKey}"]`,
                );
                if (monthSection) {
                    monthSection.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                    });
                }
            }, 10);
        });
    });

    // Listen for date filter changes from activity heatmap
    window.addEventListener("dateFilterChange", (e: any) => {
        currentDateFilter = e.detail.date;
        itemsToShow = 10;
        updateDisplay();
    });

    // Listen for display updates when new months are revealed
    window.addEventListener("updateDisplayNeeded", () => {
        updateDisplay();
    });

    // Prevent any interference with timeline event clicks
    document.querySelectorAll(".timeline-event").forEach((event) => {
        event.addEventListener(
            "click",
            (e) => {
                e.stopPropagation();
            },
            true,
        );
        event.addEventListener("focus", (e) => e.stopPropagation(), true);
        event.addEventListener("blur", (e) => e.stopPropagation(), true);
    });

    // Automatically select current year or preserved year on initial load
    // We run this immediately because the script is at the bottom of the body
    const initYearSelection = () => {
        const savedYear = localStorage.getItem('selectedYear');
        const currentYearStr = new Date().getFullYear().toString();
        const yearToSelect = savedYear || currentYearStr;

        let yearBtn = document.querySelector(
            `.year-btn[data-year="${yearToSelect}"]`,
        ) as HTMLElement;

        // If saved year button doesn't exist anymore, fallback to current year
        if (!yearBtn && savedYear) {
            yearBtn = document.querySelector(
                `.year-btn[data-year="${currentYearStr}"]`,
            ) as HTMLElement;
        }

        if (yearBtn) {
            selectYear(yearBtn.dataset.year || currentYearStr, yearBtn, false);
        } else {
            const allYearBtns = document.querySelectorAll(".year-btn");
            if (allYearBtns.length > 0) {
                const firstBtn = allYearBtns[0] as HTMLElement;
                selectYear(firstBtn.dataset.year || currentYearStr, firstBtn, false);
            }
        }

        // Handover: Signaling that JS is ready to handle filtering.
        // This removes the "initial batch" CSS restriction.
        document.documentElement.classList.add('js-initialized');
    };

    initYearSelection();
</script>
