---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "../layouts/Layout.astro";
import ActivityHeatmap from "../components/Profile/ActivityHeatmap.astro";
import ProfileHeader from "../components/Profile/ProfileHeader.astro";
import YearNavigation from "../components/YearNavigation.astro";
import PostTimeline from "../components/PostTimeline.astro";
import SiteFooter from "../components/SiteFooter.astro";
import Search from "../components/Navigation/Search.astro";
import { getBatchFileDates } from "../lib/git-history";

const allPosts = await getCollection("posts");
const batchDates = await getBatchFileDates();

// Fetch git dates for all posts to create timeline events
const postsWithDates = allPosts.map((post) => {
    const filePath = `src/content/posts/${post.id}`;
    const dates = batchDates.get(filePath);
    const created = dates?.created;
    const updated = dates?.updated;

    return {
        ...post,
        displayDate: post.data.publishedDate || created || new Date(),
        updatedDate: updated || created || new Date(),
    };
});

// Create timeline events
const events: any[] = [];
postsWithDates.forEach((post) => {
    // Add creation event
    events.push({
        type: "created",
        post,
        date: post.displayDate,
        title: post.data.title,
    });

    // Add update event if updated significantly later
    if (
        post.updatedDate.getTime() >
        post.displayDate.getTime() + 1000 * 60 * 60
    ) {
        // More than 1 hour
        events.push({
            type: "updated",
            post,
            date: post.updatedDate,
            title: post.data.title,
        });
    }
});

// Aggregate events: group multiple updates to same post within short time
const aggregatedEvents: any[] = [];
const eventGroups = new Map();

events.forEach((event) => {
    const key = `${event.post.slug}-${event.type}`;
    if (!eventGroups.has(key)) {
        eventGroups.set(key, []);
    }
    eventGroups.get(key).push(event);
});

eventGroups.forEach((group) => {
    if (group.length === 1) {
        aggregatedEvents.push(group[0]);
    } else {
        // Multiple events, aggregate them
        const firstEvent = group[0];
        const lastEvent = group[group.length - 1];
        aggregatedEvents.push({
            ...firstEvent,
            count: group.length,
            date: lastEvent.date, // Use the most recent date
        });
    }
});

// Sort events by date descending
const sortedEvents = aggregatedEvents.sort(
    (a, b) => b.date.valueOf() - a.date.valueOf(),
);

// Generate all months from earliest event to now
const earliestDate =
    sortedEvents.length > 0
        ? sortedEvents[sortedEvents.length - 1]?.date || new Date()
        : new Date();
const latestDate =
    sortedEvents.length > 0 ? sortedEvents[0]?.date || new Date() : new Date();

const allMonths: Array<{
    key: string;
    date: Date;
    hasActivity: boolean;
}> = [];

const currentDate = new Date();
currentDate.setDate(1); // Start from first day of current month
currentDate.setHours(0, 0, 0, 0);

const endDate = new Date(earliestDate);
endDate.setDate(1);
endDate.setHours(0, 0, 0, 0);

// Group events by month for quick lookup
const eventsByMonthKey = new Map<string, any[]>();
sortedEvents.forEach((event) => {
    const monthKey = event.date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    if (!eventsByMonthKey.has(monthKey)) {
        eventsByMonthKey.set(monthKey, []);
    }
    eventsByMonthKey.get(monthKey)?.push(event);
});

// Generate all months from current to earliest
while (currentDate >= endDate) {
    const monthKey = currentDate.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    allMonths.push({
        key: monthKey,
        date: new Date(currentDate),
        hasActivity: eventsByMonthKey.has(monthKey),
    });

    // Move to previous month
    currentDate.setMonth(currentDate.getMonth() - 1);
}

// Collect years data for sidebar
const yearsData = new Map();
sortedEvents.forEach((event) => {
    const year = event.date.getFullYear();
    const month = event.date.getMonth();

    if (!yearsData.has(year)) {
        yearsData.set(year, { count: 0, months: new Set() });
    }
    yearsData.get(year).count++;
    yearsData.get(year).months.add(month);
});

// Convert to array and sort by year descending
const yearsArray = Array.from(yearsData.entries());
yearsArray.sort((a, b) => b[0] - a[0]);
const sortedYears = yearsArray.map(([year, data]) => ({
    year: year as number,
    count: data.count as number,
    months: (Array.from(data.months) as number[]).sort((a, b) => b - a), // months descending within year
}));

// Default to current year for heatmap
const currentYear = new Date().getFullYear();
---

<Layout
    title="Sprout - A Digital Garden"
    description="A digital garden of thoughts and ideas. Explore seeds, sprouts, and trees of knowledge in this ever-growing collection of writings."
    type="website"
>
    <main class="max-w-7xl mx-auto p-4 md:p-8">
        <ProfileHeader />

        <div class="flex gap-8">
            <!-- Left Column: Activity Heatmap and Timeline -->
            <div class="flex-1 space-y-6">
                <ActivityHeatmap
                    year={currentYear}
                    events={sortedEvents as any}
                />
                <PostTimeline
                    sortedEvents={sortedEvents}
                    allMonths={allMonths}
                    eventsByMonthKey={eventsByMonthKey}
                />
            </div>

            <!-- Right Column: Search, Filters, and Years Navigation -->
            <div class="w-64 shrink-0 sticky top-8 h-fit">
                <!-- Search Garden -->
                <div
                    class="bg-white dark:bg-[#121812] border border-slate-200 dark:border-slate-800 rounded-xl p-4 mb-6"
                >
                    <Search />
                </div>

                <!-- Years Navigation -->
                <YearNavigation sortedYears={sortedYears as any} />
            </div>
        </div>
        <SiteFooter />
    </main>
</Layout>

<script>
    declare global {
        interface Window {
            updateHeatmapYear?: (year: number) => void;
        }
    }

    const buttons = document.querySelectorAll("[data-status]");
    const tagButtons = document.querySelectorAll("[data-tag]");
    const eventTypeButtons = document.querySelectorAll("[data-event-type]");
    const timelineEvents = document.querySelectorAll(".timeline-event");
    const noResults = document.getElementById("no-results");

    let currentFilter = "all";
    let currentTag = "";
    let currentEventType = "all";
    let currentYear = new Date().getFullYear().toString();
    let searchQuery = "";
    let currentDateFilter: string | null = null;

    function updateDisplay() {
        let visibleCount = 0;

        // Re-query to include dynamically added events
        const allTimelineEvents = document.querySelectorAll(".timeline-event");

        allTimelineEvents.forEach((event) => {
            const htmlEvent = event as HTMLElement;
            const status = htmlEvent.dataset.status;
            const title = htmlEvent.dataset.title || "";
            const summary = htmlEvent.dataset.summary || "";
            const tags = htmlEvent.dataset.tags || "";
            const eventYear = htmlEvent.dataset.eventYear || "";
            const eventType = htmlEvent.dataset.eventType;

            const matchesFilter =
                currentFilter === "all" || status === currentFilter;
            const matchesTag = currentTag === "" || tags.includes(currentTag);
            const matchesEventType =
                currentEventType === "all" || eventType === currentEventType;
            const matchesYear =
                currentYear === "all" || eventYear === currentYear;
            const matchesSearch =
                title.includes(searchQuery) ||
                summary.includes(searchQuery) ||
                tags.includes(searchQuery);
            
            // If filtering by a specific date from the heatmap
            const eventDate = htmlEvent.dataset.created || ""; 
            const matchesDate =
                currentDateFilter === null ||
                eventDate === currentDateFilter;

            if (
                matchesFilter &&
                matchesTag &&
                matchesEventType &&
                matchesYear &&
                matchesSearch &&
                matchesDate
            ) {
                htmlEvent.style.display = "flex";
                visibleCount++;
            } else {
                htmlEvent.style.display = "none";
            }
        });

        // Show/hide month sections based on their visible events
        document.querySelectorAll(".month-section").forEach((section) => {
            const htmlSection = section as HTMLElement;
            const eventsInSection = Array.from(htmlSection.querySelectorAll(".timeline-event"));
            const hasVisibleEvent = eventsInSection.some(e => (e as HTMLElement).style.display !== "none");
            
            if (hasVisibleEvent) {
                htmlSection.style.display = "block";
            } else {
                htmlSection.style.display = "none";
            }
        });

        // Ensure containers are not blocking visibility if they contain visible things
        const hiddenMonthsContainer = document.getElementById("hidden-months");
        if (hiddenMonthsContainer) {
            if (currentFilter !== "all" || currentTag !== "" || currentEventType !== "all" || currentYear !== "all" || searchQuery !== "" || currentDateFilter !== null) {
                hiddenMonthsContainer.classList.remove("hidden");
                const showMoreButton = document.getElementById("show-more-activity");
                if (showMoreButton) showMoreButton.style.display = "none";
            }
        }

        if (noResults) {
            if (visibleCount === 0) noResults.classList.remove("hidden");
            else noResults.classList.add("hidden");
        }
    }

    buttons.forEach((button) => {
        button.addEventListener("click", () => {
            const status = (button as HTMLElement).dataset.status || "all";
            if (currentFilter === status) {
                button.classList.remove("active");
                currentFilter = "all";
            } else {
                buttons.forEach((btn) => btn.classList.remove("active"));
                button.classList.add("active");
                currentFilter = status;
            }
            updateDisplay();
        });
    });

    tagButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const tag = (button as HTMLElement).dataset.tag || "";
            if (currentTag === tag) {
                button.classList.remove("active");
                currentTag = "";
            } else {
                tagButtons.forEach((btn) => btn.classList.remove("active"));
                button.classList.add("active");
                currentTag = tag;
            }
            updateDisplay();
        });
    });

    eventTypeButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const eventType = (button as HTMLElement).dataset.eventType || "all";
            if (currentEventType === eventType) {
                button.classList.remove("active");
                currentEventType = "all";
            } else {
                eventTypeButtons.forEach((btn) => btn.classList.remove("active"));
                button.classList.add("active");
                currentEventType = eventType;
            }
            updateDisplay();
        });
    });

    // Year navigation
    const yearButtons = document.querySelectorAll(".year-btn");

    yearButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const year = (button as HTMLElement).dataset.year || "all";
            const yearItem = button.closest(".year-item") as HTMLElement;
            const monthSubmenu = yearItem?.querySelector(".month-submenu") as HTMLElement;

            if (currentYear === year) {
                if (monthSubmenu) {
                    monthSubmenu.classList.toggle("hidden");
                }
            } else {
                yearButtons.forEach((btn) => {
                    btn.classList.remove("active");
                    const item = btn.closest(".year-item");
                    const submenu = item?.querySelector(".month-submenu");
                    if (submenu) submenu.classList.add("hidden");
                });
                button.classList.add("active");
                currentYear = year;

                if (monthSubmenu) {
                    monthSubmenu.classList.remove("hidden");
                }

                if (window.updateHeatmapYear) {
                    window.updateHeatmapYear(parseInt(year));
                }
            }
            updateDisplay();
        });
    });

    // Listen for date filter changes from activity heatmap
    window.addEventListener("dateFilterChange", (e: any) => {
        currentDateFilter = e.detail.date;
        updateDisplay();
    });

    // Listen for display updates when new months are revealed
    window.addEventListener("updateDisplayNeeded", () => {
        updateDisplay();
    });

    // Prevent any interference with timeline event clicks
    document.querySelectorAll(".timeline-event").forEach((event) => {
        event.addEventListener("click", (e) => { e.stopPropagation(); }, true);
        event.addEventListener("focus", (e) => e.stopPropagation(), true);
        event.addEventListener("blur", (e) => e.stopPropagation(), true);
    });

    // Check URL params for initial tag filter
    const urlParams = new URLSearchParams(window.location.search);
    const tagParam = urlParams.get("tag");
    if (tagParam) {
        currentTag = tagParam;
        const targetTagBtn = Array.from(tagButtons).find((btn) => (btn as HTMLElement).dataset.tag === tagParam);
        if (targetTagBtn) {
            targetTagBtn.classList.add("active");
            tagButtons.forEach((btn) => {
                if (btn !== targetTagBtn) btn.classList.remove("active");
            });
        }
        updateDisplay();
    }

    // Automatically select current year on initial load
    window.addEventListener("DOMContentLoaded", () => {
        const yearStr = new Date().getFullYear().toString();
        const yearBtn = document.querySelector(`.year-btn[data-year="${yearStr}"]`);
        
        currentYear = "all";

        if (yearBtn) {
            (yearBtn as HTMLElement).click();
        } else {
            const allYearBtns = document.querySelectorAll(".year-btn");
            if (allYearBtns.length > 0) {
                (allYearBtns[0] as HTMLElement).click();
            }
        }
    });
</script>
